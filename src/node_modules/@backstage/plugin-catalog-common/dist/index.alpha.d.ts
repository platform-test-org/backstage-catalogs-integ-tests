/**
 * Provides shared objects useful for interacting with the catalog and its
 * entities, such as catalog permissions.
 *
 * @packageDocumentation
 */

import { BasicPermission } from '@backstage/plugin-permission-common';
import { Entity } from '@backstage/catalog-model';
import { IndexableDocument } from '@backstage/plugin-search-common';
import { ResourcePermission } from '@backstage/plugin-permission-common';

/** @public */
export declare type AnalyzeLocationEntityField = {
    /**
     * e.g. "spec.owner"? The frontend needs to know how to "inject" the field into the
     * entity again if the user wants to change it
     */
    field: string;
    /** The outcome of the analysis for this particular field */
    state: 'analysisSuggestedValue' | 'analysisSuggestedNoValue' | 'needsUserInput';
    value: string | null;
    /**
     * A text to show to the user to inform about the choices made. Like, it could say
     * "Found a CODEOWNERS file that covers this target, so we suggest leaving this
     * field empty; which would currently make it owned by X" where X is taken from the
     * codeowners file.
     */
    description: string;
};

/**
 * If the folder pointed to already contained catalog info yaml files, they are
 * read and emitted like this so that the frontend can inform the user that it
 * located them and can make sure to register them as well if they weren't
 * already
 * @public
 */
export declare type AnalyzeLocationExistingEntity = {
    location: LocationSpec;
    isRegistered: boolean;
    entity: Entity;
};

/**
 * This is some form of representation of what the analyzer could deduce.
 * We should probably have a chat about how this can best be conveyed to
 * the frontend. It'll probably contain a (possibly incomplete) entity, plus
 * enough info for the frontend to know what form data to show to the user
 * for overriding/completing the info.
 * @public
 */
export declare type AnalyzeLocationGenerateEntity = {
    entity: RecursivePartial<Entity>;
    fields: AnalyzeLocationEntityField[];
};

/** @public */
export declare type AnalyzeLocationRequest = {
    location: LocationSpec;
    catalogFilename?: string;
};

/** @public */
export declare type AnalyzeLocationResponse = {
    existingEntityFiles: AnalyzeLocationExistingEntity[];
    generateEntities: AnalyzeLocationGenerateEntity[];
};

/**
 * This permission is used to authorize actions that involve creating a new
 * catalog entity. This includes registering an existing component into the
 * catalog.
 * @alpha
 */
export declare const catalogEntityCreatePermission: BasicPermission;

/**
 * This permission is used to designate actions that involve removing one or
 * more entities from the catalog.
 * @alpha
 */
export declare const catalogEntityDeletePermission: ResourcePermission<"catalog-entity">;

/**
 * The Document format for an Entity in the Catalog for search
 *
 * @public
 */
export declare interface CatalogEntityDocument extends IndexableDocument {
    /** @deprecated `componentType` is being renamed to `type`. During the transition both of these fields should be set to the same value, in order to avoid issues with indexing. */
    componentType: string;
    type: string;
    namespace: string;
    kind: string;
    lifecycle: string;
    owner: string;
}

/**
 * Convenience type for catalog entity
 * {@link @backstage/plugin-permission-common#ResourcePermission}s.
 * @alpha
 */
export declare type CatalogEntityPermission = ResourcePermission<typeof RESOURCE_TYPE_CATALOG_ENTITY>;

/**
 * This permission is used to authorize actions that involve reading one or more
 * entities from the catalog.
 *
 * If this permission is not authorized, it will appear that the entity does not
 * exist in the catalog — both in the frontend and in API responses.
 * @alpha
 */
export declare const catalogEntityReadPermission: ResourcePermission<"catalog-entity">;

/**
 * This permission is used to designate refreshing one or more entities from the
 * catalog.
 * @alpha
 */
export declare const catalogEntityRefreshPermission: ResourcePermission<"catalog-entity">;

/**
 * This permission is used to designate actions that involve creating catalog
 * locations.
 * @alpha
 */
export declare const catalogLocationCreatePermission: BasicPermission;

/**
 * This permission is used to designate actions that involve deleting locations
 * from the catalog.
 * @alpha
 */
export declare const catalogLocationDeletePermission: BasicPermission;

/**
 * This permission is used to designate actions that involve reading one or more
 * locations from the catalog.
 *
 * If this permission is not authorized, it will appear that the location does
 * not exist in the catalog — both in the frontend and in API responses.
 * @alpha
 */
export declare const catalogLocationReadPermission: BasicPermission;

/**
 * List of all catalog permissions.
 * @alpha
 */
export declare const catalogPermissions: (BasicPermission | ResourcePermission<"catalog-entity">)[];

/**
 * Holds the entity location information.
 *
 * @remarks
 *
 *  `presence` flag: when using repo importer plugin, location is being created before the component yaml file is merged to the main branch.
 *  This flag is then set to indicate that the file can be not present.
 *  default value: 'required'.
 *
 * @public
 */
export declare type LocationSpec = {
    type: string;
    target: string;
    presence?: 'optional' | 'required';
};

/**
 * Makes all keys of an entire hierarchy optional.
 * @ignore
 */
declare type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object ? RecursivePartial<T[P]> : T[P];
};

/**
 * Permission resource type which corresponds to catalog entities.
 *
 * {@link https://backstage.io/docs/features/software-catalog/software-catalog-overview}
 * @alpha
 */
export declare const RESOURCE_TYPE_CATALOG_ENTITY = "catalog-entity";

export { }
