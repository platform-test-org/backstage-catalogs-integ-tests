/**
 * The Backstage backend plugin that helps you create new things
 *
 * @packageDocumentation
 */

/// <reference types="node" />

import { BackendFeature } from '@backstage/backend-plugin-api';
import { CatalogApi } from '@backstage/catalog-client';
import { CatalogProcessor } from '@backstage/plugin-catalog-backend';
import { CatalogProcessorEmit } from '@backstage/plugin-catalog-backend';
import { Config } from '@backstage/config';
import { createPullRequest } from 'octokit-plugin-create-pull-request';
import { Entity } from '@backstage/catalog-model';
import express from 'express';
import { GithubCredentialsProvider } from '@backstage/integration';
import { IdentityApi } from '@backstage/plugin-auth-node';
import { JsonObject } from '@backstage/types';
import { JsonValue } from '@backstage/types';
import { Knex } from 'knex';
import { LocationSpec } from '@backstage/plugin-catalog-backend';
import { Logger } from 'winston';
import { Observable } from '@backstage/types';
import { Octokit } from 'octokit';
import { PluginDatabaseManager } from '@backstage/backend-common';
import { PluginTaskScheduler } from '@backstage/backend-tasks';
import { Schema } from 'jsonschema';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { ScmIntegrations } from '@backstage/integration';
import { SpawnOptionsWithoutStdio } from 'child_process';
import { TaskSpec } from '@backstage/plugin-scaffolder-common';
import { TaskSpecV1beta3 } from '@backstage/plugin-scaffolder-common';
import { TemplateInfo } from '@backstage/plugin-scaffolder-common';
import { UrlReader } from '@backstage/backend-common';
import { UserEntity } from '@backstage/catalog-model';
import { Writable } from 'stream';

/**
 * ActionContext is passed into scaffolder actions.
 * @public
 */
export declare type ActionContext<Input extends JsonObject> = {
    logger: Logger;
    logStream: Writable;
    secrets?: TaskSecrets;
    workspacePath: string;
    input: Input;
    output(name: string, value: JsonValue): void;
    /**
     * Creates a temporary directory for use by the action, which is then cleaned up automatically.
     */
    createTemporaryDirectory(): Promise<string>;
    templateInfo?: TemplateInfo;
    /**
     * Whether this action invocation is a dry-run or not.
     * This will only ever be true if the actions as marked as supporting dry-runs.
     */
    isDryRun?: boolean;
    /**
     * The user which triggered the action.
     */
    user?: {
        /**
         * The decorated entity from the Catalog
         */
        entity?: UserEntity;
        /**
         * An entity ref for the author of the task
         */
        ref?: string;
    };
};

/**
 * A function to generate create a list of default actions that the scaffolder provides.
 * Is called internally in the default setup, but can be used when adding your own actions or overriding the default ones
 *
 * @public
 * @returns A list of actions that can be used in the scaffolder
 */
export declare const createBuiltinActions: (options: CreateBuiltInActionsOptions) => TemplateAction<JsonObject>[];

/**
 * The options passed to {@link createBuiltinActions}
 * @public
 */
export declare interface CreateBuiltInActionsOptions {
    /**
     * The {@link @backstage/backend-common#UrlReader} interface that will be used in the default actions.
     */
    reader: UrlReader;
    /**
     * The {@link @backstage/integrations#ScmIntegrations} that will be used in the default actions.
     */
    integrations: ScmIntegrations;
    /**
     * The {@link @backstage/catalog-client#CatalogApi} that will be used in the default actions.
     */
    catalogClient: CatalogApi;
    /**
     * The {@link @backstage/config#Config} that will be used in the default actions.
     */
    config: Config;
    /**
     * Additional custom filters that will be passed to the nunjucks template engine for use in
     * Template Manifests and also template skeleton files when using `fetch:template`.
     */
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}

/**
 * Registers entities from a catalog descriptor file in the workspace into the software catalog.
 * @public
 */
export declare function createCatalogRegisterAction(options: {
    catalogClient: CatalogApi;
    integrations: ScmIntegrations;
}): TemplateAction<    {
catalogInfoUrl: string;
optional?: boolean | undefined;
} | {
repoContentsUrl: string;
catalogInfoPath?: string | undefined;
optional?: boolean | undefined;
}>;

/**
 * Writes a catalog descriptor file containing the provided entity to a path in the workspace.
 * @public
 */
export declare function createCatalogWriteAction(): TemplateAction<    {
filePath?: string | undefined;
entity: Entity;
}>;

/**
 * Writes a message into the log or lists all files in the workspace
 *
 * @remarks
 *
 * This task is useful for local development and testing of both the scaffolder
 * and scaffolder templates.
 *
 * @public
 */
export declare function createDebugLogAction(): TemplateAction<    {
message?: string | undefined;
listWorkspace?: boolean | undefined;
}>;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
export declare function createFetchPlainAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
}): TemplateAction<    {
url: string;
targetPath?: string | undefined;
}>;

/**
 * Downloads a skeleton, templates variables into file and directory names and content.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 *
 * @public
 */
export declare function createFetchTemplateAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}): TemplateAction<    {
url: string;
targetPath?: string | undefined;
values: any;
templateFileExtension?: string | boolean | undefined;
/**
* @deprecated This field is deprecated in favor of copyWithoutTemplating.
*/
copyWithoutRender?: string[] | undefined;
copyWithoutTemplating?: string[] | undefined;
cookiecutterCompat?: boolean | undefined;
}>;

/**
 * Creates new action that enables deletion of files and directories in the workspace.
 * @public
 */
export declare const createFilesystemDeleteAction: () => TemplateAction<    {
files: string[];
}>;

/**
 * Creates a new action that allows renames of files and directories in the workspace.
 * @public
 */
export declare const createFilesystemRenameAction: () => TemplateAction<    {
files: Array<{
from: string;
to: string;
overwrite?: boolean;
}>;
}>;

/**
 * Creates a new action that dispatches a GitHub Action workflow for a given branch or tag.
 * @public
 */
export declare function createGithubActionsDispatchAction(options: {
    integrations: ScmIntegrations;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): TemplateAction<    {
repoUrl: string;
workflowId: string;
branchOrTagName: string;
workflowInputs?: {
[key: string]: string;
} | undefined;
token?: string | undefined;
}>;

/**
 * Adds labels to a pull request or issue on GitHub
 * @public
 */
export declare function createGithubIssuesLabelAction(options: {
    integrations: ScmIntegrationRegistry;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): TemplateAction<    {
repoUrl: string;
number: number;
labels: string[];
token?: string | undefined;
}>;

/**
 * The options passed to {@link createPublishGithubPullRequestAction} method
 * @public
 */
export declare interface CreateGithubPullRequestActionOptions {
    /**
     * An instance of {@link @backstage/integration#ScmIntegrationRegistry} that will be used in the action.
     */
    integrations: ScmIntegrationRegistry;
    /**
     * An instance of {@link @backstage/integration#GithubCredentialsProvider} that will be used to get credentials for the action.
     */
    githubCredentialsProvider?: GithubCredentialsProvider;
    /**
     * A method to return the Octokit client with the Pull Request Plugin.
     */
    clientFactory?: (input: CreateGithubPullRequestClientFactoryInput) => Promise<OctokitWithPullRequestPluginClient>;
}

/**
 * The options passed to the client factory function.
 * @public
 */
export declare type CreateGithubPullRequestClientFactoryInput = {
    integrations: ScmIntegrationRegistry;
    githubCredentialsProvider?: GithubCredentialsProvider;
    host: string;
    owner: string;
    repo: string;
    token?: string;
};

/**
 * Creates a new action that initializes a git repository
 *
 * @public
 */
export declare function createGithubRepoCreateAction(options: {
    integrations: ScmIntegrationRegistry;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): TemplateAction<    {
repoUrl: string;
description?: string | undefined;
homepage?: string | undefined;
access?: string | undefined;
deleteBranchOnMerge?: boolean | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
allowRebaseMerge?: boolean | undefined;
allowSquashMerge?: boolean | undefined;
allowMergeCommit?: boolean | undefined;
allowAutoMerge?: boolean | undefined;
requireCodeOwnerReviews?: boolean | undefined;
bypassPullRequestAllowances?: {
users?: string[] | undefined;
teams?: string[] | undefined;
apps?: string[] | undefined;
} | undefined;
requiredStatusCheckContexts?: string[] | undefined;
requireBranchesToBeUpToDate?: boolean | undefined;
repoVisibility?: "internal" | "private" | "public" | undefined;
collaborators?: ({
user: string;
access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
} | {
team: string;
access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
} | {
/** @deprecated This field is deprecated in favor of team */
username: string;
access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
})[] | undefined;
token?: string | undefined;
topics?: string[] | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to GitHub.
 *
 * @public
 */
export declare function createGithubRepoPushAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): TemplateAction<    {
repoUrl: string;
description?: string | undefined;
defaultBranch?: string | undefined;
protectDefaultBranch?: boolean | undefined;
protectEnforceAdmins?: boolean | undefined;
gitCommitMessage?: string | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
requireCodeOwnerReviews?: boolean | undefined;
bypassPullRequestAllowances?: {
users?: string[];
teams?: string[];
apps?: string[];
} | undefined;
requiredStatusCheckContexts?: string[] | undefined;
requireBranchesToBeUpToDate?: boolean | undefined;
sourcePath?: string | undefined;
token?: string | undefined;
}>;

/**
 * Creates new action that creates a webhook for a repository on GitHub.
 * @public
 */
export declare function createGithubWebhookAction(options: {
    integrations: ScmIntegrationRegistry;
    defaultWebhookSecret?: string;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): TemplateAction<    {
repoUrl: string;
webhookUrl: string;
webhookSecret?: string | undefined;
events?: string[] | undefined;
active?: boolean | undefined;
contentType?: "form" | "json" | undefined;
insecureSsl?: boolean | undefined;
token?: string | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Azure.
 * @public
 */
export declare function createPublishAzureAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): TemplateAction<    {
repoUrl: string;
description?: string | undefined;
defaultBranch?: string | undefined;
sourcePath?: string | undefined;
token?: string | undefined;
gitCommitMessage?: string | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Bitbucket.
 * @public
 * @deprecated in favor of createPublishBitbucketCloudAction and createPublishBitbucketServerAction
 */
export declare function createPublishBitbucketAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): TemplateAction<    {
repoUrl: string;
description?: string | undefined;
defaultBranch?: string | undefined;
repoVisibility?: "private" | "public" | undefined;
sourcePath?: string | undefined;
enableLFS?: boolean | undefined;
token?: string | undefined;
gitCommitMessage?: string | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Bitbucket Cloud.
 * @public
 */
export declare function createPublishBitbucketCloudAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): TemplateAction<    {
repoUrl: string;
description?: string | undefined;
defaultBranch?: string | undefined;
repoVisibility?: "private" | "public" | undefined;
sourcePath?: string | undefined;
token?: string | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to Bitbucket Server.
 * @public
 */
export declare function createPublishBitbucketServerAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): TemplateAction<    {
repoUrl: string;
description?: string | undefined;
defaultBranch?: string | undefined;
repoVisibility?: "private" | "public" | undefined;
sourcePath?: string | undefined;
enableLFS?: boolean | undefined;
token?: string | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to a Gerrit instance.
 * @public
 */
export declare function createPublishGerritAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): TemplateAction<    {
repoUrl: string;
description: string;
defaultBranch?: string | undefined;
gitCommitMessage?: string | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
sourcePath?: string | undefined;
}>;

/**
 * Creates a new action that creates a Gerrit review
 * @public
 */
export declare function createPublishGerritReviewAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): TemplateAction<    {
repoUrl: string;
branch?: string | undefined;
sourcePath?: string | undefined;
gitCommitMessage?: string | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to GitHub.
 *
 * @public
 */
export declare function createPublishGithubAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
    githubCredentialsProvider?: GithubCredentialsProvider;
}): TemplateAction<    {
repoUrl: string;
description?: string | undefined;
homepage?: string | undefined;
access?: string | undefined;
defaultBranch?: string | undefined;
protectDefaultBranch?: boolean | undefined;
protectEnforceAdmins?: boolean | undefined;
deleteBranchOnMerge?: boolean | undefined;
gitCommitMessage?: string | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
allowRebaseMerge?: boolean | undefined;
allowSquashMerge?: boolean | undefined;
allowMergeCommit?: boolean | undefined;
allowAutoMerge?: boolean | undefined;
sourcePath?: string | undefined;
bypassPullRequestAllowances?: {
users?: string[];
teams?: string[];
apps?: string[];
} | undefined;
requireCodeOwnerReviews?: boolean | undefined;
requiredStatusCheckContexts?: string[] | undefined;
requireBranchesToBeUpToDate?: boolean | undefined;
repoVisibility?: "internal" | "private" | "public" | undefined;
collaborators?: ({
user: string;
access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
} | {
team: string;
access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
} | {
/** @deprecated This field is deprecated in favor of team */
username: string;
access: 'pull' | 'push' | 'admin' | 'maintain' | 'triage';
})[] | undefined;
token?: string | undefined;
topics?: string[] | undefined;
}>;

/**
 * Creates a Github Pull Request action.
 * @public
 */
export declare const createPublishGithubPullRequestAction: ({ integrations, githubCredentialsProvider, clientFactory, }: CreateGithubPullRequestActionOptions) => TemplateAction<    {
title: string;
branchName: string;
description: string;
repoUrl: string;
draft?: boolean | undefined;
targetPath?: string | undefined;
sourcePath?: string | undefined;
token?: string | undefined;
reviewers?: string[] | undefined;
teamReviewers?: string[] | undefined;
}>;

/**
 * Creates a new action that initializes a git repository of the content in the workspace
 * and publishes it to GitLab.
 *
 * @public
 */
export declare function createPublishGitlabAction(options: {
    integrations: ScmIntegrationRegistry;
    config: Config;
}): TemplateAction<    {
repoUrl: string;
defaultBranch?: string | undefined;
repoVisibility?: "internal" | "private" | "public" | undefined;
sourcePath?: string | undefined;
token?: string | undefined;
gitCommitMessage?: string | undefined;
gitAuthorName?: string | undefined;
gitAuthorEmail?: string | undefined;
setUserAsOwner?: boolean | undefined;
topics?: string[] | undefined;
}>;

/**
 * Create a new action that creates a gitlab merge request.
 *
 * @public
 */
export declare const createPublishGitlabMergeRequestAction: (options: {
    integrations: ScmIntegrationRegistry;
}) => TemplateAction<    {
repoUrl: string;
title: string;
description: string;
branchName: string;
sourcePath?: string | undefined;
targetPath?: string | undefined;
token?: string | undefined;
commitAction?: "update" | "create" | "delete" | undefined;
/** @deprecated projectID passed as query parameters in the repoUrl */
projectid?: string | undefined;
removeSourceBranch?: boolean | undefined;
assignee?: string | undefined;
}>;

/**
 * A method to create a router for the scaffolder backend plugin.
 * @public
 */
export declare function createRouter(options: RouterOptions): Promise<express.Router>;

/**
 * This function is used to create new template actions to get type safety.
 * @public
 */
export declare const createTemplateAction: <TInput extends JsonObject>(templateAction: TemplateAction<TInput>) => TemplateAction<TInput>;

/**
 * CreateWorkerOptions
 *
 * @public
 */
export declare type CreateWorkerOptions = {
    taskBroker: TaskBroker;
    actionRegistry: TemplateActionRegistry;
    integrations: ScmIntegrations;
    workingDirectory: string;
    logger: Logger;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
};

/**
 * Stores the state of the current claimed task passed to the TaskContext
 *
 * @public
 */
export declare interface CurrentClaimedTask {
    /**
     * The TaskSpec of the current claimed task.
     */
    spec: TaskSpec;
    /**
     * The uuid of the current claimed task.
     */
    taskId: string;
    /**
     * The secrets that are stored with the task.
     */
    secrets?: TaskSecrets;
    /**
     * The creator of the task.
     */
    createdBy?: string;
}

/**
 * DatabaseTaskStore
 *
 * @public
 */
export declare class DatabaseTaskStore implements TaskStore {
    private readonly db;
    static create(options: DatabaseTaskStoreOptions): Promise<DatabaseTaskStore>;
    private static getClient;
    private static runMigrations;
    private constructor();
    list(options: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
    getTask(taskId: string): Promise<SerializedTask>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    claimTask(): Promise<SerializedTask | undefined>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    emitLogEvent(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask({ taskId }: TaskStoreShutDownTaskOptions): Promise<void>;
}

/**
 * DatabaseTaskStore
 *
 * @public
 */
export declare type DatabaseTaskStoreOptions = {
    database: PluginDatabaseManager | Knex;
};

/**
 * Run a command in a sub-process, normally a shell command.
 *
 * @public
 */
export declare const executeShellCommand: (options: RunCommandOptions) => Promise<void>;

/**
 * A helper function that reads the contents of a directory from the given URL.
 * Can be used in your own actions, and also used behind fetch:template and fetch:plain
 *
 * @public
 */
export declare function fetchContents(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    baseUrl?: string;
    fetchUrl?: string;
    outputPath: string;
}): Promise<void>;

/** @public */
export declare type OctokitWithPullRequestPluginClient = Octokit & {
    createPullRequest(options: createPullRequest.Options): Promise<{
        data: {
            html_url: string;
            number: number;
        };
    } | null>;
};

/**
 * RouterOptions
 *
 * @public
 */
export declare interface RouterOptions {
    logger: Logger;
    config: Config;
    reader: UrlReader;
    database: PluginDatabaseManager;
    catalogClient: CatalogApi;
    scheduler?: PluginTaskScheduler;
    actions?: TemplateAction<any>[];
    taskWorkers?: number;
    taskBroker?: TaskBroker;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
    identity?: IdentityApi;
}

/** @public */
export declare type RunCommandOptions = {
    /** command to run */
    command: string;
    /** arguments to pass the command */
    args: string[];
    /** options to pass to spawn */
    options?: SpawnOptionsWithoutStdio;
    /** stream to capture stdout and stderr output */
    logStream?: Writable;
};

/**
 * @alpha
 * Registers the ScaffolderEntitiesProcessor with the catalog processing extension point.
 */
export declare const scaffolderCatalogModule: (options?: undefined) => BackendFeature;

/** @public */
export declare class ScaffolderEntitiesProcessor implements CatalogProcessor {
    getProcessorName(): string;
    private readonly validators;
    validateEntityKind(entity: Entity): Promise<boolean>;
    postProcessEntity(entity: Entity, _location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
}

/**
 * Catalog plugin
 * @alpha
 */
export declare const scaffolderPlugin: (options: ScaffolderPluginOptions) => BackendFeature;

/**
 * Catalog plugin options
 * @alpha
 */
export declare type ScaffolderPluginOptions = {
    actions?: TemplateAction<any>[];
    taskWorkers?: number;
    taskBroker?: TaskBroker;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
};

/**
 * SerializedTask
 *
 * @public
 */
export declare type SerializedTask = {
    id: string;
    spec: TaskSpec;
    status: TaskStatus;
    createdAt: string;
    lastHeartbeatAt?: string;
    createdBy?: string;
    secrets?: TaskSecrets;
};

/**
 * SerializedTaskEvent
 *
 * @public
 */
export declare type SerializedTaskEvent = {
    id: number;
    taskId: string;
    body: JsonObject;
    type: TaskEventType;
    createdAt: string;
};

/**
 * TaskBroker
 *
 * @public
 */
export declare interface TaskBroker {
    claim(): Promise<TaskContext>;
    dispatch(options: TaskBrokerDispatchOptions): Promise<TaskBrokerDispatchResult>;
    vacuumTasks(options: {
        timeoutS: number;
    }): Promise<void>;
    event$(options: {
        taskId: string;
        after: number | undefined;
    }): Observable<{
        events: SerializedTaskEvent[];
    }>;
    get(taskId: string): Promise<SerializedTask>;
    list?(options?: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
}

/**
 * The options passed to {@link TaskBroker.dispatch}
 * Currently a spec and optional secrets
 *
 * @public
 */
export declare type TaskBrokerDispatchOptions = {
    spec: TaskSpec;
    secrets?: TaskSecrets;
    createdBy?: string;
};

/**
 * The result of {@link TaskBroker.dispatch}
 *
 * @public
 */
export declare type TaskBrokerDispatchResult = {
    taskId: string;
};

/**
 * The state of a completed task.
 *
 * @public
 */
export declare type TaskCompletionState = 'failed' | 'completed';

/**
 * Task
 *
 * @public
 */
export declare interface TaskContext {
    spec: TaskSpec;
    secrets?: TaskSecrets;
    createdBy?: string;
    done: boolean;
    isDryRun?: boolean;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    getWorkspaceName(): Promise<string>;
}

/**
 * TaskEventType
 *
 * @public
 */
export declare type TaskEventType = 'completion' | 'log';

/**
 * TaskManager
 *
 * @public
 */
export declare class TaskManager implements TaskContext {
    private readonly task;
    private readonly storage;
    private readonly logger;
    private isDone;
    private heartbeatTimeoutId?;
    static create(task: CurrentClaimedTask, storage: TaskStore, logger: Logger): TaskManager;
    private constructor();
    get spec(): TaskSpecV1beta3;
    get secrets(): TaskSecrets | undefined;
    get createdBy(): string | undefined;
    getWorkspaceName(): Promise<string>;
    get done(): boolean;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    private startTimeout;
}

/**
 * TaskSecrets
 *
 * @public
 */
export declare type TaskSecrets = Record<string, string> & {
    backstageToken?: string;
};

/**
 * The status of each step of the Task
 *
 * @public
 */
export declare type TaskStatus = 'open' | 'processing' | 'failed' | 'cancelled' | 'completed';

/**
 * TaskStore
 *
 * @public
 */
export declare interface TaskStore {
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    getTask(taskId: string): Promise<SerializedTask>;
    claimTask(): Promise<SerializedTask | undefined>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    list?(options: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
    emitLogEvent({ taskId, body }: TaskStoreEmitOptions): Promise<void>;
    listEvents({ taskId, after, }: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask?({ taskId }: TaskStoreShutDownTaskOptions): Promise<void>;
}

/**
 * The options passed to {@link TaskStore.createTask}
 * @public
 */
export declare type TaskStoreCreateTaskOptions = {
    spec: TaskSpec;
    createdBy?: string;
    secrets?: TaskSecrets;
};

/**
 * The response from {@link TaskStore.createTask}
 * @public
 */
export declare type TaskStoreCreateTaskResult = {
    taskId: string;
};

/**
 * TaskStoreEmitOptions
 *
 * @public
 */
export declare type TaskStoreEmitOptions<TBody = JsonObject> = {
    taskId: string;
    body: TBody;
};

/**
 * TaskStoreListEventsOptions
 *
 * @public
 */
export declare type TaskStoreListEventsOptions = {
    taskId: string;
    after?: number | undefined;
};

/**
 * TaskStoreShutDownTaskOptions
 *
 * @public
 */
export declare type TaskStoreShutDownTaskOptions = {
    taskId: string;
};

/**
 * TaskWorker
 *
 * @public
 */
export declare class TaskWorker {
    private readonly options;
    private constructor();
    static create(options: CreateWorkerOptions): Promise<TaskWorker>;
    start(): void;
    runOneTask(task: TaskContext): Promise<void>;
}

/** @public */
export declare type TemplateAction<Input extends JsonObject> = {
    id: string;
    description?: string;
    supportsDryRun?: boolean;
    schema?: {
        input?: Schema;
        output?: Schema;
    };
    handler: (ctx: ActionContext<Input>) => Promise<void>;
};

/**
 * Registry of all registered template actions.
 * @public
 */
export declare class TemplateActionRegistry {
    private readonly actions;
    register<TInput extends JsonObject>(action: TemplateAction<TInput>): void;
    get(actionId: string): TemplateAction<JsonObject>;
    list(): TemplateAction<JsonObject>[];
}

/** @public */
export declare type TemplateFilter = (...args: JsonValue[]) => JsonValue | undefined;

/** @public */
export declare type TemplateGlobal = ((...args: JsonValue[]) => JsonValue | undefined) | JsonValue;

export { }
