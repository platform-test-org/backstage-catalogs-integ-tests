import { createApiRef, AnalyticsContext, useApi, useAnalytics, configApiRef } from '@backstage/core-plugin-api';
import React, { useMemo, useContext, useState, useCallback, useEffect, forwardRef, useRef } from 'react';
import { makeStyles, InputBase, InputAdornment, IconButton, CircularProgress, ListItemIcon, ListItemText, TextField, Chip, FormControl, FormLabel, FormControlLabel, Checkbox, InputLabel, Select, MenuItem, Button, TablePagination, ListItem, Box, Divider, List, Typography, ListSubheader, Menu } from '@material-ui/core';
import useDebounce from 'react-use/lib/useDebounce';
import SearchIcon from '@material-ui/icons/Search';
import ClearButton from '@material-ui/icons/Clear';
import { isEqual } from 'lodash';
import useAsync from 'react-use/lib/useAsync';
import usePrevious from 'react-use/lib/usePrevious';
import { createVersionedContext, createVersionedValueMap } from '@backstage/version-bridge';
import { Autocomplete } from '@material-ui/lab';
import useAsyncFn from 'react-use/lib/useAsyncFn';
import { Progress, ResponseErrorPanel, EmptyState, Link } from '@backstage/core-components';
import ArrowBackIosIcon from '@material-ui/icons/ArrowBackIos';
import ArrowForwardIosIcon from '@material-ui/icons/ArrowForwardIos';
import qs from 'qs';
import AddIcon from '@material-ui/icons/Add';

const searchApiRef = createApiRef({
  id: "plugin.search.queryservice"
});
class MockSearchApi {
  constructor(mockedResults) {
    this.mockedResults = mockedResults;
  }
  query() {
    return Promise.resolve(this.mockedResults || { results: [] });
  }
}

const useStyles$3 = makeStyles(
  () => ({
    highlight: {}
  }),
  { name: "BackstageHighlightedSearchResultText" }
);
const HighlightedSearchResultText = ({
  text,
  preTag,
  postTag
}) => {
  const classes = useStyles$3();
  const terms = useMemo(
    () => text.split(new RegExp(`(${preTag}.+?${postTag})`)),
    [postTag, preTag, text]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, terms.map(
    (t, idx) => t.includes(preTag) ? /* @__PURE__ */ React.createElement("mark", {
      className: classes.highlight,
      key: idx
    }, t.replace(new RegExp(`${preTag}|${postTag}`, "g"), "")) : t
  ));
};

const SearchContext = createVersionedContext("search-context");
const useSearch = () => {
  const context = useContext(SearchContext);
  if (!context) {
    throw new Error("useSearch must be used within a SearchContextProvider");
  }
  const value = context.atVersion(1);
  if (!value) {
    throw new Error("No SearchContext v1 found");
  }
  return value;
};
const useSearchContextCheck = () => {
  const context = useContext(SearchContext);
  return context !== void 0;
};
const searchInitialState = {
  term: "",
  types: [],
  filters: {},
  pageLimit: void 0,
  pageCursor: void 0
};
const useSearchContextValue = (initialValue = searchInitialState) => {
  var _a, _b, _c, _d;
  const searchApi = useApi(searchApiRef);
  const [term, setTerm] = useState(initialValue.term);
  const [types, setTypes] = useState(initialValue.types);
  const [filters, setFilters] = useState(initialValue.filters);
  const [pageLimit, setPageLimit] = useState(
    initialValue.pageLimit
  );
  const [pageCursor, setPageCursor] = useState(
    initialValue.pageCursor
  );
  const prevTerm = usePrevious(term);
  const prevFilters = usePrevious(filters);
  const result = useAsync(
    () => searchApi.query({
      term,
      types,
      filters,
      pageLimit,
      pageCursor
    }),
    [term, types, filters, pageLimit, pageCursor]
  );
  const hasNextPage = !result.loading && !result.error && ((_a = result.value) == null ? void 0 : _a.nextPageCursor);
  const hasPreviousPage = !result.loading && !result.error && ((_b = result.value) == null ? void 0 : _b.previousPageCursor);
  const fetchNextPage = useCallback(() => {
    var _a2;
    setPageCursor((_a2 = result.value) == null ? void 0 : _a2.nextPageCursor);
  }, [(_c = result.value) == null ? void 0 : _c.nextPageCursor]);
  const fetchPreviousPage = useCallback(() => {
    var _a2;
    setPageCursor((_a2 = result.value) == null ? void 0 : _a2.previousPageCursor);
  }, [(_d = result.value) == null ? void 0 : _d.previousPageCursor]);
  useEffect(() => {
    if (prevTerm !== void 0 && term !== prevTerm) {
      setPageCursor(void 0);
    }
  }, [term, prevTerm, setPageCursor]);
  useEffect(() => {
    if (prevFilters !== void 0 && !isEqual(filters, prevFilters)) {
      setPageCursor(void 0);
    }
  }, [filters, prevFilters, setPageCursor]);
  const value = {
    result,
    term,
    setTerm,
    types,
    setTypes,
    filters,
    setFilters,
    pageLimit,
    setPageLimit,
    pageCursor,
    setPageCursor,
    fetchNextPage: hasNextPage ? fetchNextPage : void 0,
    fetchPreviousPage: hasPreviousPage ? fetchPreviousPage : void 0
  };
  return value;
};
const LocalSearchContext = (props) => {
  const { initialState, children } = props;
  const value = useSearchContextValue(initialState);
  return /* @__PURE__ */ React.createElement(AnalyticsContext, {
    attributes: { searchTypes: value.types.sort().join(",") }
  }, /* @__PURE__ */ React.createElement(SearchContext.Provider, {
    value: createVersionedValueMap({ 1: value })
  }, children));
};
const SearchContextProvider = (props) => {
  const { initialState, inheritParentContextIfAvailable, children } = props;
  const hasParentContext = useSearchContextCheck();
  return hasParentContext && inheritParentContextIfAvailable ? /* @__PURE__ */ React.createElement(React.Fragment, null, children) : /* @__PURE__ */ React.createElement(LocalSearchContext, {
    initialState
  }, children);
};

const TrackSearch = ({ children }) => {
  const analytics = useAnalytics();
  const { term } = useSearch();
  useEffect(() => {
    if (term) {
      analytics.captureEvent("search", term);
    }
  }, [analytics, term]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};

function withContext$1(Component) {
  return forwardRef((props, ref) => /* @__PURE__ */ React.createElement(SearchContextProvider, {
    inheritParentContextIfAvailable: true
  }, /* @__PURE__ */ React.createElement(Component, {
    ...props,
    ref
  })));
}
const SearchBarBase = withContext$1(
  forwardRef((props, ref) => {
    const {
      onChange,
      onKeyDown = () => {
      },
      onClear = () => {
      },
      onSubmit = () => {
      },
      debounceTime = 200,
      clearButton = true,
      fullWidth = true,
      value: defaultValue,
      placeholder: defaultPlaceholder,
      inputProps: defaultInputProps = {},
      endAdornment: defaultEndAdornment,
      ...rest
    } = props;
    const configApi = useApi(configApiRef);
    const [value, setValue] = useState("");
    useEffect(() => {
      setValue(
        (prevValue) => prevValue !== defaultValue ? String(defaultValue) : prevValue
      );
    }, [defaultValue]);
    useDebounce(() => onChange(value), debounceTime, [value]);
    const handleChange = useCallback(
      (e) => {
        setValue(e.target.value);
      },
      [setValue]
    );
    const handleKeyDown = useCallback(
      (e) => {
        if (onKeyDown)
          onKeyDown(e);
        if (onSubmit && e.key === "Enter") {
          onSubmit();
        }
      },
      [onKeyDown, onSubmit]
    );
    const handleClear = useCallback(() => {
      onChange("");
      if (onClear) {
        onClear();
      }
    }, [onChange, onClear]);
    const placeholder = defaultPlaceholder != null ? defaultPlaceholder : `Search in ${configApi.getOptionalString("app.title") || "Backstage"}`;
    const startAdornment = /* @__PURE__ */ React.createElement(InputAdornment, {
      position: "start"
    }, /* @__PURE__ */ React.createElement(IconButton, {
      "aria-label": "Query",
      size: "small",
      disabled: true
    }, /* @__PURE__ */ React.createElement(SearchIcon, null)));
    const endAdornment = /* @__PURE__ */ React.createElement(InputAdornment, {
      position: "end"
    }, /* @__PURE__ */ React.createElement(IconButton, {
      "aria-label": "Clear",
      size: "small",
      onClick: handleClear
    }, /* @__PURE__ */ React.createElement(ClearButton, null)));
    return /* @__PURE__ */ React.createElement(TrackSearch, null, /* @__PURE__ */ React.createElement(InputBase, {
      "data-testid": "search-bar-next",
      ref,
      value,
      placeholder,
      startAdornment,
      endAdornment: clearButton ? endAdornment : defaultEndAdornment,
      inputProps: { "aria-label": "Search", ...defaultInputProps },
      fullWidth,
      onChange: handleChange,
      onKeyDown: handleKeyDown,
      ...rest
    }));
  })
);
const SearchBar = withContext$1(
  forwardRef((props, ref) => {
    const { value: initialValue = "", onChange, ...rest } = props;
    const { term, setTerm } = useSearch();
    useEffect(() => {
      if (initialValue) {
        setTerm(String(initialValue));
      }
    }, [initialValue, setTerm]);
    const handleChange = useCallback(
      (newValue) => {
        if (onChange) {
          onChange(newValue);
        } else {
          setTerm(newValue);
        }
      },
      [onChange, setTerm]
    );
    return /* @__PURE__ */ React.createElement(AnalyticsContext, {
      attributes: { pluginId: "search", extension: "SearchBar" }
    }, /* @__PURE__ */ React.createElement(SearchBarBase, {
      ...rest,
      ref,
      value: term,
      onChange: handleChange
    }));
  })
);

const withContext = (Component) => {
  return (props) => /* @__PURE__ */ React.createElement(SearchContextProvider, {
    inheritParentContextIfAvailable: true
  }, /* @__PURE__ */ React.createElement(Component, {
    ...props
  }));
};
const SearchAutocomplete = withContext(
  function SearchAutocompleteComponent(props) {
    const {
      loading,
      value,
      onChange = () => {
      },
      options = [],
      getOptionLabel = (option) => String(option),
      inputPlaceholder,
      inputDebounceTime,
      freeSolo = true,
      fullWidth = true,
      clearOnBlur = false,
      "data-testid": dataTestId = "search-autocomplete",
      ...rest
    } = props;
    const { setTerm } = useSearch();
    const getInputValue = useCallback(
      (option) => {
        if (!option)
          return "";
        if (typeof option === "string")
          return option;
        return getOptionLabel(option);
      },
      [getOptionLabel]
    );
    const inputValue = useMemo(
      () => getInputValue(value),
      [value, getInputValue]
    );
    const handleChange = useCallback(
      (event, option, reason, details) => {
        setTerm(getInputValue(option));
        onChange(event, option, reason, details);
      },
      [getInputValue, setTerm, onChange]
    );
    const renderInput = useCallback(
      ({
        InputProps: { ref, endAdornment },
        InputLabelProps,
        ...params
      }) => /* @__PURE__ */ React.createElement(SearchBar, {
        ...params,
        ref,
        clearButton: false,
        value: inputValue,
        placeholder: inputPlaceholder,
        debounceTime: inputDebounceTime,
        endAdornment: loading ? /* @__PURE__ */ React.createElement(CircularProgress, {
          "data-testid": "search-autocomplete-progressbar",
          color: "inherit",
          size: 20
        }) : endAdornment
      }),
      [loading, inputValue, inputPlaceholder, inputDebounceTime]
    );
    return /* @__PURE__ */ React.createElement(Autocomplete, {
      ...rest,
      "data-testid": dataTestId,
      value,
      onChange: handleChange,
      options,
      getOptionLabel,
      renderInput,
      freeSolo,
      fullWidth,
      clearOnBlur
    });
  }
);

const SearchAutocompleteDefaultOption = ({
  icon,
  primaryText,
  primaryTextTypographyProps,
  secondaryText,
  secondaryTextTypographyProps,
  disableTextTypography
}) => /* @__PURE__ */ React.createElement(React.Fragment, null, icon ? /* @__PURE__ */ React.createElement(ListItemIcon, null, icon) : null, /* @__PURE__ */ React.createElement(ListItemText, {
  primary: primaryText,
  primaryTypographyProps: primaryTextTypographyProps,
  secondary: secondaryText,
  secondaryTypographyProps: secondaryTextTypographyProps,
  disableTypography: disableTextTypography
}));

const useAsyncFilterValues = (fn, inputValue, defaultValues = [], debounce = 250) => {
  const valuesMemo = useRef({});
  const definiteFn = fn || (() => Promise.resolve([]));
  const [state, callback] = useAsyncFn(definiteFn, [inputValue], {
    loading: true
  });
  useDebounce(
    () => {
      if (valuesMemo.current[inputValue] === void 0) {
        valuesMemo.current[inputValue] = callback(inputValue).then((values) => {
          valuesMemo.current[inputValue] = values;
          return values;
        });
      }
    },
    debounce,
    [callback, inputValue]
  );
  if (defaultValues.length) {
    return {
      loading: false,
      value: defaultValues
    };
  }
  const possibleValue = valuesMemo.current[inputValue];
  if (Array.isArray(possibleValue)) {
    return {
      loading: false,
      value: possibleValue
    };
  }
  return state;
};
const useDefaultFilterValue = (name, defaultValue) => {
  const { setFilters } = useSearch();
  useEffect(() => {
    if (defaultValue && [defaultValue].flat().length > 0) {
      setFilters((prevFilters) => ({
        ...prevFilters,
        [name]: defaultValue
      }));
    }
  }, []);
};

const AutocompleteFilter = (props) => {
  const {
    className,
    defaultValue,
    name,
    values: givenValues,
    valuesDebounceMs,
    label,
    filterSelectedOptions,
    limitTags,
    multiple
  } = props;
  const [inputValue, setInputValue] = useState("");
  useDefaultFilterValue(name, defaultValue);
  const asyncValues = typeof givenValues === "function" ? givenValues : void 0;
  const defaultValues = typeof givenValues === "function" ? void 0 : givenValues;
  const { value: values, loading } = useAsyncFilterValues(
    asyncValues,
    inputValue,
    defaultValues,
    valuesDebounceMs
  );
  const { filters, setFilters } = useSearch();
  const filterValue = filters[name] || (multiple ? [] : null);
  const handleChange = (_, newValue) => {
    setFilters((prevState) => {
      const { [name]: filter, ...others } = prevState;
      if (newValue) {
        return { ...others, [name]: newValue };
      }
      return { ...others };
    });
  };
  const renderInput = (params) => /* @__PURE__ */ React.createElement(TextField, {
    ...params,
    name: "search",
    variant: "outlined",
    label,
    fullWidth: true
  });
  const renderTags = (tagValue, getTagProps) => tagValue.map((option, index) => /* @__PURE__ */ React.createElement(Chip, {
    label: option,
    color: "primary",
    ...getTagProps({ index })
  }));
  return /* @__PURE__ */ React.createElement(Autocomplete, {
    filterSelectedOptions,
    limitTags,
    multiple,
    className,
    id: `${multiple ? "multi-" : ""}select-filter-${name}--select`,
    options: values || [],
    loading,
    value: filterValue,
    onChange: handleChange,
    onInputChange: (_, newValue) => setInputValue(newValue),
    renderInput,
    renderTags
  });
};

const useStyles$2 = makeStyles({
  label: {
    textTransform: "capitalize"
  }
});
const CheckboxFilter = (props) => {
  const {
    className,
    defaultValue,
    label,
    name,
    values: givenValues = [],
    valuesDebounceMs
  } = props;
  const classes = useStyles$2();
  const { filters, setFilters } = useSearch();
  useDefaultFilterValue(name, defaultValue);
  const asyncValues = typeof givenValues === "function" ? givenValues : void 0;
  const defaultValues = typeof givenValues === "function" ? void 0 : givenValues;
  const { value: values = [], loading } = useAsyncFilterValues(
    asyncValues,
    "",
    defaultValues,
    valuesDebounceMs
  );
  const handleChange = (e) => {
    const {
      target: { value, checked }
    } = e;
    setFilters((prevFilters) => {
      const { [name]: filter, ...others } = prevFilters;
      const rest = (filter || []).filter((i) => i !== value);
      const items = checked ? [...rest, value] : rest;
      return items.length ? { ...others, [name]: items } : others;
    });
  };
  return /* @__PURE__ */ React.createElement(FormControl, {
    className,
    disabled: loading,
    fullWidth: true,
    "data-testid": "search-checkboxfilter-next"
  }, label ? /* @__PURE__ */ React.createElement(FormLabel, {
    className: classes.label
  }, label) : null, values.map((value) => {
    var _a;
    return /* @__PURE__ */ React.createElement(FormControlLabel, {
      key: value,
      control: /* @__PURE__ */ React.createElement(Checkbox, {
        color: "primary",
        tabIndex: -1,
        inputProps: { "aria-labelledby": value },
        value,
        name: value,
        onChange: handleChange,
        checked: ((_a = filters[name]) != null ? _a : []).includes(value)
      }),
      label: value
    });
  }));
};
const SelectFilter = (props) => {
  const {
    className,
    defaultValue,
    label,
    name,
    values: givenValues,
    valuesDebounceMs
  } = props;
  const classes = useStyles$2();
  useDefaultFilterValue(name, defaultValue);
  const asyncValues = typeof givenValues === "function" ? givenValues : void 0;
  const defaultValues = typeof givenValues === "function" ? void 0 : givenValues;
  const { value: values = [], loading } = useAsyncFilterValues(
    asyncValues,
    "",
    defaultValues,
    valuesDebounceMs
  );
  const { filters, setFilters } = useSearch();
  const handleChange = (e) => {
    const {
      target: { value }
    } = e;
    setFilters((prevFilters) => {
      const { [name]: filter, ...others } = prevFilters;
      return value ? { ...others, [name]: value } : others;
    });
  };
  return /* @__PURE__ */ React.createElement(FormControl, {
    disabled: loading,
    className,
    variant: "filled",
    fullWidth: true,
    "data-testid": "search-selectfilter-next"
  }, label ? /* @__PURE__ */ React.createElement(InputLabel, {
    className: classes.label,
    margin: "dense"
  }, label) : null, /* @__PURE__ */ React.createElement(Select, {
    variant: "outlined",
    value: filters[name] || "",
    onChange: handleChange
  }, /* @__PURE__ */ React.createElement(MenuItem, {
    value: ""
  }, /* @__PURE__ */ React.createElement("em", null, "All")), values.map((value) => /* @__PURE__ */ React.createElement(MenuItem, {
    key: value,
    value
  }, value))));
};
const SearchFilter = ({
  component: Element,
  ...props
}) => /* @__PURE__ */ React.createElement(Element, {
  ...props
});
SearchFilter.Checkbox = (props) => /* @__PURE__ */ React.createElement(SearchFilter, {
  ...props,
  component: CheckboxFilter
});
SearchFilter.Select = (props) => /* @__PURE__ */ React.createElement(SearchFilter, {
  ...props,
  component: SelectFilter
});
SearchFilter.Autocomplete = (props) => /* @__PURE__ */ React.createElement(SearchFilter, {
  ...props,
  component: AutocompleteFilter
});

const SearchResultContext = (props) => {
  const { children } = props;
  const context = useSearch();
  const state = context.result;
  return children(state);
};
const SearchResultApi = (props) => {
  const { query, children } = props;
  const searchApi = useApi(searchApiRef);
  const state = useAsync(() => {
    const { term = "", types = [], filters = {}, ...rest } = query;
    return searchApi.query({ ...rest, term, types, filters });
  }, [query]);
  return children(state);
};
const SearchResultState = (props) => {
  const { query, children } = props;
  return query ? /* @__PURE__ */ React.createElement(SearchResultApi, {
    query
  }, children) : /* @__PURE__ */ React.createElement(SearchResultContext, null, children);
};
const SearchResultComponent = (props) => {
  const { query, children } = props;
  return /* @__PURE__ */ React.createElement(SearchResultState, {
    query
  }, ({ loading, error, value }) => {
    if (loading) {
      return /* @__PURE__ */ React.createElement(Progress, null);
    }
    if (error) {
      return /* @__PURE__ */ React.createElement(ResponseErrorPanel, {
        title: "Error encountered while fetching search results",
        error
      });
    }
    if (!(value == null ? void 0 : value.results.length)) {
      return /* @__PURE__ */ React.createElement(EmptyState, {
        missing: "data",
        title: "Sorry, no results were found"
      });
    }
    return children(value);
  });
};
const SearchResult = (props) => /* @__PURE__ */ React.createElement(AnalyticsContext, {
  attributes: {
    pluginId: "search",
    extension: "SearchResult"
  }
}, /* @__PURE__ */ React.createElement(SearchResultComponent, {
  ...props
}));

const useStyles$1 = makeStyles((theme) => ({
  root: {
    display: "flex",
    justifyContent: "space-between",
    gap: theme.spacing(2),
    margin: theme.spacing(2, 0)
  }
}));
const SearchResultPager = () => {
  const { fetchNextPage, fetchPreviousPage } = useSearch();
  const classes = useStyles$1();
  if (!fetchNextPage && !fetchPreviousPage) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null);
  }
  return /* @__PURE__ */ React.createElement("nav", {
    "aria-label": "pagination navigation",
    className: classes.root
  }, /* @__PURE__ */ React.createElement(Button, {
    "aria-label": "previous page",
    disabled: !fetchPreviousPage,
    onClick: fetchPreviousPage,
    startIcon: /* @__PURE__ */ React.createElement(ArrowBackIosIcon, null)
  }, "Previous"), /* @__PURE__ */ React.createElement(Button, {
    "aria-label": "next page",
    disabled: !fetchNextPage,
    onClick: fetchNextPage,
    endIcon: /* @__PURE__ */ React.createElement(ArrowForwardIosIcon, null)
  }, "Next"));
};

const encodePageCursor = (pageCursor) => {
  return Buffer.from(pageCursor.toString(), "utf-8").toString("base64");
};
const decodePageCursor = (pageCursor) => {
  if (!pageCursor)
    return 0;
  return Number(Buffer.from(pageCursor, "base64").toString("utf-8"));
};
const SearchPaginationBase = (props) => {
  const {
    total: count = -1,
    cursor: pageCursor,
    onCursorChange: onPageCursorChange,
    limit: rowsPerPage = 25,
    limitLabel: labelRowsPerPage = "Results per page:",
    limitText: labelDisplayedRows = ({ from, to }) => count > 0 ? `of ${count}` : `${from}-${to}`,
    limitOptions: rowsPerPageOptions,
    onLimitChange: onPageLimitChange,
    ...rest
  } = props;
  const page = useMemo(() => decodePageCursor(pageCursor), [pageCursor]);
  const handlePageChange = useCallback(
    (_, newValue) => {
      onPageCursorChange == null ? void 0 : onPageCursorChange(encodePageCursor(newValue));
    },
    [onPageCursorChange]
  );
  const handleRowsPerPageChange = useCallback(
    (e) => {
      const newValue = e.target.value;
      onPageLimitChange == null ? void 0 : onPageLimitChange(parseInt(newValue, 10));
    },
    [onPageLimitChange]
  );
  return /* @__PURE__ */ React.createElement(TablePagination, {
    ...rest,
    component: "div",
    count,
    page,
    onPageChange: handlePageChange,
    rowsPerPage,
    labelRowsPerPage,
    labelDisplayedRows,
    rowsPerPageOptions,
    onRowsPerPageChange: handleRowsPerPageChange
  });
};
const SearchPagination = (props) => {
  const { pageLimit, setPageLimit, pageCursor, setPageCursor } = useSearch();
  return /* @__PURE__ */ React.createElement(SearchPaginationBase, {
    ...props,
    limit: pageLimit,
    onLimitChange: setPageLimit,
    cursor: pageCursor,
    onCursorChange: setPageCursor
  });
};

const DefaultResultListItemComponent = ({
  result,
  highlight,
  rank,
  icon,
  secondaryAction,
  lineClamp = 5
}) => {
  const analytics = useAnalytics();
  const handleClick = () => {
    analytics.captureEvent("discover", result.title, {
      attributes: { to: result.location },
      value: rank
    });
  };
  return /* @__PURE__ */ React.createElement(Link, {
    noTrack: true,
    to: result.location,
    onClick: handleClick
  }, /* @__PURE__ */ React.createElement(ListItem, {
    alignItems: "center"
  }, icon && /* @__PURE__ */ React.createElement(ListItemIcon, null, icon), /* @__PURE__ */ React.createElement(ListItemText, {
    primaryTypographyProps: { variant: "h6" },
    primary: (highlight == null ? void 0 : highlight.fields.title) ? /* @__PURE__ */ React.createElement(HighlightedSearchResultText, {
      text: highlight.fields.title,
      preTag: highlight.preTag,
      postTag: highlight.postTag
    }) : result.title,
    secondary: /* @__PURE__ */ React.createElement("span", {
      style: {
        display: "-webkit-box",
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: lineClamp,
        overflow: "hidden"
      }
    }, (highlight == null ? void 0 : highlight.fields.text) ? /* @__PURE__ */ React.createElement(HighlightedSearchResultText, {
      text: highlight.fields.text,
      preTag: highlight.preTag,
      postTag: highlight.postTag
    }) : result.text)
  }), secondaryAction && /* @__PURE__ */ React.createElement(Box, {
    alignItems: "flex-end"
  }, secondaryAction)), /* @__PURE__ */ React.createElement(Divider, null));
};
const HigherOrderDefaultResultListItem = (props) => {
  return /* @__PURE__ */ React.createElement(AnalyticsContext, {
    attributes: {
      pluginId: "search",
      extension: "DefaultResultListItem"
    }
  }, /* @__PURE__ */ React.createElement(DefaultResultListItemComponent, {
    ...props
  }));
};

const SearchResultListLayout = (props) => {
  const {
    loading,
    error,
    resultItems,
    renderResultItem = (resultItem) => /* @__PURE__ */ React.createElement(HigherOrderDefaultResultListItem, {
      key: resultItem.document.location,
      result: resultItem.document
    }),
    noResultsComponent = /* @__PURE__ */ React.createElement(EmptyState, {
      missing: "data",
      title: "Sorry, no results were found"
    }),
    ...rest
  } = props;
  return /* @__PURE__ */ React.createElement(List, {
    ...rest
  }, loading ? /* @__PURE__ */ React.createElement(Progress, null) : null, !loading && error ? /* @__PURE__ */ React.createElement(ResponseErrorPanel, {
    title: "Error encountered while fetching search results",
    error
  }) : null, !loading && !error && (resultItems == null ? void 0 : resultItems.length) ? resultItems.map(renderResultItem) : null, !loading && !error && !(resultItems == null ? void 0 : resultItems.length) ? /* @__PURE__ */ React.createElement(ListItem, null, noResultsComponent) : null);
};
const SearchResultList = (props) => {
  const { query, disableRenderingWithNoResults, ...rest } = props;
  return /* @__PURE__ */ React.createElement(AnalyticsContext, {
    attributes: {
      pluginId: "search",
      extension: "SearchResultList"
    }
  }, /* @__PURE__ */ React.createElement(SearchResultState, {
    query
  }, ({ loading, error, value }) => {
    var _a;
    if (!((_a = value == null ? void 0 : value.results) == null ? void 0 : _a.length) && disableRenderingWithNoResults) {
      return null;
    }
    return /* @__PURE__ */ React.createElement(SearchResultListLayout, {
      ...rest,
      loading,
      error,
      resultItems: value == null ? void 0 : value.results
    });
  }));
};

const useStyles = makeStyles((theme) => ({
  listSubheader: {
    display: "flex",
    alignItems: "center"
  },
  listSubheaderName: {
    marginLeft: theme.spacing(1),
    textTransform: "uppercase"
  },
  listSubheaderChip: {
    color: theme.palette.text.secondary,
    margin: theme.spacing(0, 0, 0, 1.5)
  },
  listSubheaderFilter: {
    display: "flex",
    color: theme.palette.text.secondary,
    margin: theme.spacing(0, 0, 0, 1.5)
  },
  listSubheaderLink: {
    marginLeft: "auto",
    display: "flex",
    alignItems: "center"
  },
  listSubheaderLinkIcon: {
    fontSize: "inherit",
    marginLeft: theme.spacing(0.5)
  }
}));
const SearchResultGroupFilterFieldLayout = (props) => {
  const classes = useStyles();
  const { label, children, ...rest } = props;
  return /* @__PURE__ */ React.createElement(Chip, {
    ...rest,
    className: classes.listSubheaderFilter,
    variant: "outlined",
    label: /* @__PURE__ */ React.createElement(React.Fragment, null, label, ": ", children)
  });
};
const NullIcon = () => null;
const useSearchResultGroupTextFilterStyles = makeStyles((theme) => ({
  root: {
    fontSize: "inherit",
    "&:focus": {
      outline: "none",
      background: theme.palette.common.white
    },
    "&:not(:focus)": {
      cursor: "pointer",
      color: theme.palette.primary.main,
      "&:hover": {
        textDecoration: "underline"
      }
    }
  }
}));
const SearchResultGroupTextFilterField = (props) => {
  const classes = useSearchResultGroupTextFilterStyles();
  const { label, value = "None", onChange, onDelete } = props;
  const handleChange = useCallback(
    (e) => {
      onChange(e.target.value);
    },
    [onChange]
  );
  return /* @__PURE__ */ React.createElement(SearchResultGroupFilterFieldLayout, {
    label,
    onDelete
  }, /* @__PURE__ */ React.createElement(Typography, {
    role: "textbox",
    component: "span",
    className: classes.root,
    onChange: handleChange,
    contentEditable: true,
    suppressContentEditableWarning: true
  }, value));
};
const useSearchResultGroupSelectFilterStyles = makeStyles((theme) => ({
  root: {
    fontSize: "inherit",
    "&:not(:focus)": {
      cursor: "pointer",
      color: theme.palette.primary.main,
      "&:hover": {
        textDecoration: "underline"
      }
    },
    "&:focus": {
      outline: "none"
    },
    "&>div:first-child": {
      padding: 0
    }
  }
}));
const SearchResultGroupSelectFilterField = (props) => {
  const classes = useSearchResultGroupSelectFilterStyles();
  const { label, value = "none", onChange, onDelete, children } = props;
  const handleChange = useCallback(
    (e) => {
      onChange(e.target.value);
    },
    [onChange]
  );
  return /* @__PURE__ */ React.createElement(SearchResultGroupFilterFieldLayout, {
    label,
    onDelete
  }, /* @__PURE__ */ React.createElement(Select, {
    className: classes.root,
    value,
    onChange: handleChange,
    input: /* @__PURE__ */ React.createElement(InputBase, null),
    IconComponent: NullIcon
  }, /* @__PURE__ */ React.createElement(MenuItem, {
    value: "none"
  }, "None"), children));
};
function SearchResultGroupLayout(props) {
  const classes = useStyles();
  const [anchorEl, setAnchorEl] = useState(null);
  const {
    loading,
    error,
    icon,
    title,
    titleProps = {},
    link = /* @__PURE__ */ React.createElement(React.Fragment, null, "See all", /* @__PURE__ */ React.createElement(ArrowForwardIosIcon, {
      className: classes.listSubheaderLinkIcon
    })),
    linkProps = {},
    filterOptions,
    renderFilterOption = (filterOption) => /* @__PURE__ */ React.createElement(MenuItem, {
      key: String(filterOption),
      value: String(filterOption)
    }, filterOption),
    filterFields,
    renderFilterField,
    resultItems,
    renderResultItem = (resultItem) => /* @__PURE__ */ React.createElement(HigherOrderDefaultResultListItem, {
      key: resultItem.document.location,
      result: resultItem.document
    }),
    noResultsComponent = /* @__PURE__ */ React.createElement(EmptyState, {
      missing: "data",
      title: "Sorry, no results were found"
    }),
    ...rest
  } = props;
  const handleClick = useCallback((e) => {
    setAnchorEl(e.currentTarget);
  }, []);
  const handleClose = useCallback(() => {
    setAnchorEl(null);
  }, []);
  return /* @__PURE__ */ React.createElement(List, {
    ...rest
  }, /* @__PURE__ */ React.createElement(ListSubheader, {
    className: classes.listSubheader
  }, icon, /* @__PURE__ */ React.createElement(Typography, {
    className: classes.listSubheaderName,
    component: "strong",
    ...titleProps
  }, title), filterOptions ? /* @__PURE__ */ React.createElement(Chip, {
    className: classes.listSubheaderChip,
    component: "button",
    icon: /* @__PURE__ */ React.createElement(AddIcon, null),
    variant: "outlined",
    label: "Add filter",
    "aria-controls": "filters-menu",
    "aria-haspopup": "true",
    onClick: handleClick
  }) : null, filterOptions ? /* @__PURE__ */ React.createElement(Menu, {
    id: "filters-menu",
    anchorEl,
    open: Boolean(anchorEl),
    onClose: handleClose,
    onClick: handleClose,
    keepMounted: true
  }, filterOptions.map(renderFilterOption)) : null, filterFields == null ? void 0 : filterFields.map(
    (filterField) => {
      var _a;
      return (_a = renderFilterField == null ? void 0 : renderFilterField(filterField)) != null ? _a : null;
    }
  ), /* @__PURE__ */ React.createElement(Link, {
    className: classes.listSubheaderLink,
    to: "/search",
    ...linkProps
  }, link)), loading ? /* @__PURE__ */ React.createElement(Progress, null) : null, !loading && error ? /* @__PURE__ */ React.createElement(ResponseErrorPanel, {
    title: "Error encountered while fetching search results",
    error
  }) : null, !loading && !error && (resultItems == null ? void 0 : resultItems.length) ? resultItems.map(renderResultItem) : null, !loading && !error && !(resultItems == null ? void 0 : resultItems.length) ? /* @__PURE__ */ React.createElement(ListItem, null, noResultsComponent) : null);
}
function SearchResultGroup(props) {
  const {
    query,
    linkProps = {},
    disableRenderingWithNoResults,
    ...rest
  } = props;
  const to = `/search?${qs.stringify(
    {
      query: query.term,
      types: query.types,
      filters: query.filters,
      pageCursor: query.pageCursor
    },
    { arrayFormat: "brackets" }
  )}`;
  return /* @__PURE__ */ React.createElement(AnalyticsContext, {
    attributes: {
      pluginId: "search",
      extension: "SearchResultGroup"
    }
  }, /* @__PURE__ */ React.createElement(SearchResultState, {
    query
  }, ({ loading, error, value }) => {
    var _a, _b;
    if (!((_a = value == null ? void 0 : value.results) == null ? void 0 : _a.length) && disableRenderingWithNoResults) {
      return null;
    }
    return /* @__PURE__ */ React.createElement(SearchResultGroupLayout, {
      ...rest,
      loading,
      error,
      linkProps: { to, ...linkProps },
      resultItems: value == null ? void 0 : value.results,
      filterFields: Object.keys((_b = query.filters) != null ? _b : {})
    });
  }));
}

export { AutocompleteFilter, CheckboxFilter, HigherOrderDefaultResultListItem as DefaultResultListItem, HighlightedSearchResultText, MockSearchApi, SearchAutocomplete, SearchAutocompleteDefaultOption, SearchBar, SearchBarBase, SearchContextProvider, SearchFilter, SearchPagination, SearchPaginationBase, SearchResult, SearchResultApi, SearchResultComponent, SearchResultContext, SearchResultGroup, SearchResultGroupFilterFieldLayout, SearchResultGroupLayout, SearchResultGroupSelectFilterField, SearchResultGroupTextFilterField, SearchResultList, SearchResultListLayout, SearchResultPager, SearchResultState, SelectFilter, searchApiRef, useSearch, useSearchContextCheck };
//# sourceMappingURL=index.esm.js.map
