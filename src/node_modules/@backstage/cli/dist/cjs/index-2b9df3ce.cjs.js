'use strict';

var fs = require('fs-extra');
var index = require('./index-882e66b6.cjs.js');
var webpack = require('webpack');
var paths = require('./paths-a9c09204.cjs.js');
require('yn');
require('path');
require('react-dev-utils/FileSizeReporter');
require('react-dev-utils/formatWebpackMessages');
require('fork-ts-checker-webpack-plugin');
require('html-webpack-plugin');
require('react-dev-utils/ModuleScopePlugin');
require('run-script-webpack-plugin');
require('webpack-node-externals');
require('@backstage/cli-common');
require('@manypkg/get-packages');
require('mini-css-extract-plugin');
require('@pmmmwh/react-refresh-webpack-plugin');
require('./run-519762e1.cjs.js');
require('eslint-webpack-plugin');
require('lodash/pickBy');
var chalk = require('chalk');
var WebpackDevServer = require('webpack-dev-server');
var openBrowser = require('react-dev-utils/openBrowser');
var uniq = require('lodash/uniq');
var config = require('./config-0024efa1.cjs.js');
var Lockfile = require('./Lockfile-6785964d.cjs.js');
require('minimatch');
require('./yarn-6cd89e16.cjs.js');
var lint = require('./lint-4796aeda.cjs.js');
var packageRoles = require('./packageRoles-abec821e.cjs.js');
require('commander');
require('semver');
require('@backstage/errors');
require('./svgrTemplate-550efce6.cjs.js');
require('child_process');
require('util');
require('@backstage/config-loader');
require('@backstage/config');
require('./PackageGraph-5171a7a0.cjs.js');
require('@yarnpkg/parsers');
require('@yarnpkg/lockfile');
require('lodash/partition');
require('zod');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var webpack__default = /*#__PURE__*/_interopDefaultLegacy(webpack);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var WebpackDevServer__default = /*#__PURE__*/_interopDefaultLegacy(WebpackDevServer);
var openBrowser__default = /*#__PURE__*/_interopDefaultLegacy(openBrowser);
var uniq__default = /*#__PURE__*/_interopDefaultLegacy(uniq);

async function serveBackend(options) {
  const paths$1 = paths.resolveBundlingPaths(options);
  const config = await paths.createBackendConfig(paths$1, {
    ...options,
    isDev: true
  });
  process.env.NODE_ENV = "development";
  const compiler = webpack__default["default"](config, (err) => {
    if (err) {
      console.error(err);
    } else
      console.log("Build succeeded");
  });
  const waitForExit = async () => {
    for (const signal of ["SIGINT", "SIGTERM"]) {
      process.on(signal, () => {
        compiler.close(() => process.exit());
      });
    }
    return new Promise(() => {
    });
  };
  return waitForExit;
}

async function serveBundle(options) {
  var _a, _b;
  const url = paths.resolveBaseUrl(options.frontendConfig);
  const host = options.frontendConfig.getOptionalString("app.listen.host") || url.hostname;
  const port = options.frontendConfig.getOptionalNumber("app.listen.port") || Number(url.port) || (url.protocol === "https:" ? 443 : 80);
  const paths$1 = paths.resolveBundlingPaths(options);
  const pkgPath = paths$1.targetPackageJson;
  const pkg = await fs__default["default"].readJson(pkgPath);
  const config = await paths.createConfig(paths$1, {
    ...options,
    isDev: true,
    baseUrl: url
  });
  const compiler = webpack__default["default"](config);
  const server = new WebpackDevServer__default["default"](
    {
      hot: !process.env.CI,
      devMiddleware: {
        publicPath: (_a = config.output) == null ? void 0 : _a.publicPath,
        stats: "errors-warnings"
      },
      static: paths$1.targetPublic ? {
        publicPath: (_b = config.output) == null ? void 0 : _b.publicPath,
        directory: paths$1.targetPublic
      } : void 0,
      historyApiFallback: {
        disableDotRule: true
      },
      https: url.protocol === "https:" ? {
        cert: options.fullConfig.getString("app.https.certificate.cert"),
        key: options.fullConfig.getString("app.https.certificate.key")
      } : false,
      host,
      port,
      proxy: pkg.proxy,
      allowedHosts: [url.hostname],
      client: {
        webSocketURL: "auto://0.0.0.0:0/ws"
      }
    },
    compiler
  );
  await new Promise((resolve, reject) => {
    server.startCallback((err) => {
      if (err) {
        reject(err);
        return;
      }
      openBrowser__default["default"](url.href);
      resolve();
    });
  });
  const waitForExit = async () => {
    for (const signal of ["SIGINT", "SIGTERM"]) {
      process.on(signal, () => {
        server.close();
        process.exit();
      });
    }
    return new Promise(() => {
    });
  };
  return waitForExit;
}

async function startBackend(options) {
  await fs__default["default"].remove(index.paths.resolveTarget("dist"));
  const waitForExit = await serveBackend({
    entry: "src/index",
    checksEnabled: options.checksEnabled,
    inspectEnabled: options.inspectEnabled,
    inspectBrkEnabled: options.inspectBrkEnabled
  });
  await waitForExit();
}

async function startFrontend(options) {
  if (options.verifyVersions) {
    const lockfile = await Lockfile.Lockfile.load(index.paths.resolveTargetRoot("yarn.lock"));
    const result = lockfile.analyze({
      filter: lint.includedFilter
    });
    const problemPackages = [...result.newVersions, ...result.newRanges].map(
      ({ name: name2 }) => name2
    );
    if (problemPackages.length > 1) {
      console.log(
        chalk__default["default"].yellow(
          `\u26A0\uFE0F   Some of the following packages may be outdated or have duplicate installations:

          ${uniq__default["default"](problemPackages).join(", ")}
        `
        )
      );
      console.log(
        chalk__default["default"].yellow(
          `\u26A0\uFE0F   This can be resolved using the following command:

          yarn backstage-cli versions:check --fix
      `
        )
      );
    }
  }
  const { name } = await fs__default["default"].readJson(index.paths.resolveTarget("package.json"));
  const config$1 = await config.loadCliConfig({
    args: options.configPaths,
    fromPackage: name,
    withFilteredKeys: true
  });
  const appBaseUrl = config$1.frontendConfig.getString("app.baseUrl");
  const backendBaseUrl = config$1.frontendConfig.getString("backend.baseUrl");
  if (appBaseUrl === backendBaseUrl) {
    console.log(
      chalk__default["default"].yellow(
        `\u26A0\uFE0F   Conflict between app baseUrl and backend baseUrl:

    app.baseUrl:     ${appBaseUrl}
    backend.baseUrl: ${appBaseUrl}

    Must have unique hostname and/or ports.

    This can be resolved by changing app.baseUrl and backend.baseUrl to point to their respective local development ports.
`
      )
    );
  }
  const waitForExit = await serveBundle({
    entry: options.entry,
    checksEnabled: options.checksEnabled,
    ...config$1
  });
  await waitForExit();
}

async function command(opts) {
  const role = await packageRoles.findRoleFromCommand(opts);
  const options = {
    configPaths: opts.config,
    checksEnabled: Boolean(opts.check),
    inspectEnabled: Boolean(opts.inspect),
    inspectBrkEnabled: Boolean(opts.inspectBrk)
  };
  switch (role) {
    case "backend":
    case "backend-plugin":
    case "backend-plugin-module":
    case "node-library":
      return startBackend(options);
    case "frontend":
      return startFrontend({
        ...options,
        entry: "src/index",
        verifyVersions: true
      });
    case "web-library":
    case "frontend-plugin":
    case "frontend-plugin-module":
      return startFrontend({ entry: "dev/index", ...options });
    default:
      throw new Error(
        `Start command is not supported for package role '${role}'`
      );
  }
}

exports.command = command;
//# sourceMappingURL=index-2b9df3ce.cjs.js.map
