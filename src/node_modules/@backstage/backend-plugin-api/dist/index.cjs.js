'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var winston = require('winston');
var Transport = require('winston-transport');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Transport__default = /*#__PURE__*/_interopDefaultLegacy(Transport);

function createServiceRef(options) {
  const { id, scope = "plugin", defaultFactory } = options;
  return {
    id,
    scope,
    get T() {
      throw new Error(`tried to read ServiceRef.T of ${this}`);
    },
    toString() {
      return `serviceRef{${options.id}}`;
    },
    $$ref: "service",
    __defaultFactory: defaultFactory
  };
}
function createServiceFactory(config) {
  return (options) => ({
    scope: config.service.scope,
    service: config.service,
    deps: config.deps,
    factory(deps) {
      return config.factory(deps, options);
    }
  });
}

const configServiceRef = createServiceRef({
  id: "core.root.config",
  scope: "root"
});

const httpRouterServiceRef = createServiceRef({
  id: "core.httpRouter"
});

const loggerServiceRef = createServiceRef({
  id: "core.logger"
});

const urlReaderServiceRef = createServiceRef({
  id: "core.urlReader"
});

const cacheServiceRef = createServiceRef({
  id: "core.cache"
});

const databaseServiceRef = createServiceRef({
  id: "core.database"
});

const discoveryServiceRef = createServiceRef({
  id: "core.discovery"
});

const tokenManagerServiceRef = createServiceRef({
  id: "core.tokenManager"
});

const permissionsServiceRef = createServiceRef({
  id: "core.permissions"
});

const schedulerServiceRef = createServiceRef({
  id: "core.scheduler"
});

const rootLoggerServiceRef = createServiceRef({
  id: "core.root.logger",
  scope: "root"
});

const pluginMetadataServiceRef = createServiceRef({
  id: "core.plugin-metadata"
});

class BackstageLoggerTransport extends Transport__default["default"] {
  constructor(backstageLogger, opts) {
    super(opts);
    this.backstageLogger = backstageLogger;
  }
  log(info, callback) {
    this.backstageLogger.info(info.message);
    callback();
  }
}
function loggerToWinstonLogger(logger, opts) {
  return winston.createLogger({
    transports: [new BackstageLoggerTransport(logger, opts)]
  });
}

function createExtensionPoint(options) {
  return {
    id: options.id,
    get T() {
      throw new Error(`tried to read ExtensionPoint.T of ${this}`);
    },
    toString() {
      return `extensionPoint{${options.id}}`;
    },
    $$ref: "extension-point"
  };
}
function createBackendPlugin(config) {
  return (options) => ({
    id: config.id,
    register(register) {
      return config.register(register, options);
    }
  });
}
function createBackendModule(config) {
  return (options) => ({
    id: `${config.pluginId}.${config.moduleId}`,
    register(register) {
      return config.register(register, options);
    }
  });
}

exports.cacheServiceRef = cacheServiceRef;
exports.configServiceRef = configServiceRef;
exports.createBackendModule = createBackendModule;
exports.createBackendPlugin = createBackendPlugin;
exports.createExtensionPoint = createExtensionPoint;
exports.createServiceFactory = createServiceFactory;
exports.createServiceRef = createServiceRef;
exports.databaseServiceRef = databaseServiceRef;
exports.discoveryServiceRef = discoveryServiceRef;
exports.httpRouterServiceRef = httpRouterServiceRef;
exports.loggerServiceRef = loggerServiceRef;
exports.loggerToWinstonLogger = loggerToWinstonLogger;
exports.permissionsServiceRef = permissionsServiceRef;
exports.pluginMetadataServiceRef = pluginMetadataServiceRef;
exports.rootLoggerServiceRef = rootLoggerServiceRef;
exports.schedulerServiceRef = schedulerServiceRef;
exports.tokenManagerServiceRef = tokenManagerServiceRef;
exports.urlReaderServiceRef = urlReaderServiceRef;
//# sourceMappingURL=index.cjs.js.map
