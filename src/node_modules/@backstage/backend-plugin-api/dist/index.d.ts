/**
 * Core API used by Backstage backend plugins.
 *
 * @packageDocumentation
 */

import { Config } from '@backstage/config';
import { Handler } from 'express';
import { Logger as Logger_2 } from 'winston';
import { PermissionAuthorizer } from '@backstage/plugin-permission-common';
import { PermissionEvaluator } from '@backstage/plugin-permission-common';
import { PluginCacheManager } from '@backstage/backend-common';
import { PluginDatabaseManager } from '@backstage/backend-common';
import { PluginEndpointDiscovery } from '@backstage/backend-common';
import { PluginTaskScheduler } from '@backstage/backend-tasks';
import { TokenManager } from '@backstage/backend-common';
import { TransportStreamOptions } from 'winston-transport';
import { UrlReader } from '@backstage/backend-common';

/** @public */
export declare interface BackendFeature {
    id: string;
    register(reg: BackendRegistrationPoints): void;
}

/** @public */
export declare interface BackendModuleConfig<TOptions> {
    pluginId: string;
    moduleId: string;
    register(reg: Omit<BackendRegistrationPoints, 'registerExtensionPoint'>, options: TOptions): void;
}

/** @public */
export declare interface BackendPluginConfig<TOptions> {
    id: string;
    register(reg: BackendRegistrationPoints, options: TOptions): void;
}

/** @public */
export declare interface BackendRegistrationPoints {
    registerExtensionPoint<TExtensionPoint>(ref: ExtensionPoint<TExtensionPoint>, impl: TExtensionPoint): void;
    registerInit<Deps extends {
        [name in string]: unknown;
    }>(options: {
        deps: {
            [name in keyof Deps]: ServiceRef<Deps[name]> | ExtensionPoint<Deps[name]>;
        };
        init(deps: Deps): Promise<void>;
    }): void;
}

/**
 * @public
 */
export declare const cacheServiceRef: ServiceRef<PluginCacheManager, "plugin">;

/**
 * @public
 */
export declare const configServiceRef: ServiceRef<Config, "root">;

/**
 * @public
 *
 * Creates a new backend module for a given plugin.
 *
 * The `moduleId` should be equal to the module-specific prefix of the exported name, such
 * that the full name is `moduleId + PluginId + "Module"`. For example, a GitHub entity
 * provider module for the `catalog` plugin might have the module ID `'githubEntityProvider'`,
 * and the full exported name would be `githubEntityProviderCatalogModule`.
 *
 * The `pluginId` should exactly match the `id` of the plugin that the module extends.
 */
export declare function createBackendModule<TOptions extends object | undefined = undefined>(config: BackendModuleConfig<TOptions>): undefined extends TOptions ? (options?: TOptions) => BackendFeature : (options: TOptions) => BackendFeature;

/** @public */
export declare function createBackendPlugin<TOptions extends object | undefined = undefined>(config: {
    id: string;
    register(reg: BackendRegistrationPoints, options: TOptions): void;
}): undefined extends TOptions ? (options?: TOptions) => BackendFeature : (options: TOptions) => BackendFeature;

/** @public */
export declare function createExtensionPoint<T>(options: {
    id: string;
}): ExtensionPoint<T>;

/**
 * @public
 */
export declare function createServiceFactory<TService, TScope extends 'root' | 'plugin', TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TOpts extends object | undefined = undefined>(config: {
    service: ServiceRef<TService, TScope>;
    deps: TDeps;
    factory(deps: ServiceRefsToInstances<TDeps, 'root'>, options: TOpts): TScope extends 'root' ? Promise<TImpl> : Promise<(deps: ServiceRefsToInstances<TDeps>) => Promise<TImpl>>;
}): undefined extends TOpts ? (options?: TOpts) => ServiceFactory<TService> : (options: TOpts) => ServiceFactory<TService>;

/** @public */
export declare function createServiceRef<T>(options: {
    id: string;
    scope?: 'plugin';
    defaultFactory?: (service: ServiceRef<T, 'plugin'>) => Promise<ServiceFactory<T> | (() => ServiceFactory<T>)>;
}): ServiceRef<T, 'plugin'>;

/** @public */
export declare function createServiceRef<T>(options: {
    id: string;
    scope: 'root';
    defaultFactory?: (service: ServiceRef<T, 'root'>) => Promise<ServiceFactory<T> | (() => ServiceFactory<T>)>;
}): ServiceRef<T, 'root'>;

/**
 * @public
 */
export declare const databaseServiceRef: ServiceRef<PluginDatabaseManager, "plugin">;

/**
 * @public
 */
export declare const discoveryServiceRef: ServiceRef<PluginEndpointDiscovery, "plugin">;

/**
 * TODO
 *
 * @public
 */
export declare type ExtensionPoint<T> = {
    id: string;
    /**
     * Utility for getting the type of the extension point, using `typeof extensionPoint.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: T;
    toString(): string;
    $$ref: 'extension-point';
};

/**
 * @public
 */
export declare interface HttpRouterService {
    use(handler: Handler): void;
}

/**
 * @public
 */
export declare const httpRouterServiceRef: ServiceRef<HttpRouterService, "plugin">;

/**
 * @public
 */
export declare interface Logger {
    info(message: string): void;
    child(fields: {
        [name: string]: string;
    }): Logger;
}

/**
 * @public
 */
export declare const loggerServiceRef: ServiceRef<Logger, "plugin">;

/** @public */
export declare function loggerToWinstonLogger(logger: Logger, opts?: TransportStreamOptions): Logger_2;

/**
 * @public
 */
export declare const permissionsServiceRef: ServiceRef<PermissionAuthorizer | PermissionEvaluator, "plugin">;

/**
 * @public
 */
export declare interface PluginMetadata {
    getId(): string;
}

/**
 * @public
 */
export declare const pluginMetadataServiceRef: ServiceRef<PluginMetadata, "plugin">;

/**
 * @public
 */
export declare const rootLoggerServiceRef: ServiceRef<Logger, "root">;

/**
 * @public
 */
export declare const schedulerServiceRef: ServiceRef<PluginTaskScheduler, "plugin">;

/** @public */
export declare type ServiceFactory<TService = unknown> = {
    scope: 'root';
    service: ServiceRef<TService, 'root'>;
    deps: {
        [key in string]: ServiceRef<unknown>;
    };
    factory(deps: {
        [key in string]: unknown;
    }): Promise<TService>;
} | {
    scope: 'plugin';
    service: ServiceRef<TService, 'plugin'>;
    deps: {
        [key in string]: ServiceRef<unknown>;
    };
    factory(deps: {
        [key in string]: unknown;
    }): Promise<(deps: {
        [key in string]: unknown;
    }) => Promise<TService>>;
};

/**
 * TODO
 *
 * @public
 */
export declare type ServiceRef<TService, TScope extends 'root' | 'plugin' = 'root' | 'plugin'> = {
    id: string;
    /**
     * This determines the scope at which this service is available.
     *
     * Root scoped services are available to all other services but
     * may only depend on other root scoped services.
     *
     * Plugin scoped services are only available to other plugin scoped
     * services but may depend on all other services.
     */
    scope: TScope;
    /**
     * Utility for getting the type of the service, using `typeof serviceRef.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: TService;
    toString(): string;
    $$ref: 'service';
};

/** @ignore */
declare type ServiceRefsToInstances<T extends {
    [key in string]: ServiceRef<unknown>;
}, TScope extends 'root' | 'plugin' = 'root' | 'plugin'> = {
    [name in {
        [key in keyof T]: T[key] extends ServiceRef<unknown, TScope> ? key : never;
    }[keyof T]]: T[name] extends ServiceRef<infer TImpl> ? TImpl : never;
};

/**
 * @public
 */
export declare const tokenManagerServiceRef: ServiceRef<TokenManager, "plugin">;

/** @public */
export declare type TypesToServiceRef<T> = {
    [key in keyof T]: ServiceRef<T[key]>;
};

/**
 * @public
 */
export declare const urlReaderServiceRef: ServiceRef<UrlReader, "plugin">;

export { }
