/**
 * The Backstage backend plugin that provides the Backstage catalog
 *
 * @packageDocumentation
 */

/// <reference types="node" />

import { AnalyzeLocationEntityField as AnalyzeLocationEntityField_2 } from '@backstage/plugin-catalog-common';
import { AnalyzeLocationExistingEntity as AnalyzeLocationExistingEntity_2 } from '@backstage/plugin-catalog-common';
import { AnalyzeLocationGenerateEntity as AnalyzeLocationGenerateEntity_2 } from '@backstage/plugin-catalog-common';
import { AnalyzeLocationRequest as AnalyzeLocationRequest_2 } from '@backstage/plugin-catalog-common';
import { AnalyzeLocationResponse as AnalyzeLocationResponse_2 } from '@backstage/plugin-catalog-common';
import { BackendFeature } from '@backstage/backend-plugin-api';
import { CatalogApi } from '@backstage/catalog-client';
import { CatalogEntityDocument } from '@backstage/plugin-catalog-common';
import { CatalogProcessor } from '@backstage/plugin-catalog-node';
import { CatalogProcessorCache } from '@backstage/plugin-catalog-node';
import { CatalogProcessorEmit } from '@backstage/plugin-catalog-node';
import { CatalogProcessorEntityResult } from '@backstage/plugin-catalog-node';
import { CatalogProcessorErrorResult } from '@backstage/plugin-catalog-node';
import { CatalogProcessorLocationResult } from '@backstage/plugin-catalog-node';
import { CatalogProcessorParser } from '@backstage/plugin-catalog-node';
import { CatalogProcessorRefreshKeysResult } from '@backstage/plugin-catalog-node';
import { CatalogProcessorRelationResult } from '@backstage/plugin-catalog-node';
import { CatalogProcessorResult } from '@backstage/plugin-catalog-node';
import { ConditionalPolicyDecision } from '@backstage/plugin-permission-common';
import { Conditions } from '@backstage/plugin-permission-node';
import { Config } from '@backstage/config';
import { DeferredEntity } from '@backstage/plugin-catalog-node';
import { DocumentCollatorFactory } from '@backstage/plugin-search-common';
import { Entity } from '@backstage/catalog-model';
import { EntityPolicy } from '@backstage/catalog-model';
import { EntityProvider } from '@backstage/plugin-catalog-node';
import { EntityProviderConnection } from '@backstage/plugin-catalog-node';
import { EntityProviderMutation } from '@backstage/plugin-catalog-node';
import { EntityRelationSpec } from '@backstage/plugin-catalog-node';
import { GetEntitiesRequest } from '@backstage/catalog-client';
import { JsonValue } from '@backstage/types';
import { LocationEntityV1alpha1 } from '@backstage/catalog-model';
import { LocationSpec } from '@backstage/plugin-catalog-node';
import { Logger } from 'winston';
import { Permission } from '@backstage/plugin-permission-common';
import { PermissionAuthorizer } from '@backstage/plugin-permission-common';
import { PermissionCondition } from '@backstage/plugin-permission-common';
import { PermissionCriteria } from '@backstage/plugin-permission-common';
import { PermissionEvaluator } from '@backstage/plugin-permission-common';
import { PermissionRule } from '@backstage/plugin-permission-node';
import { PermissionRuleParams } from '@backstage/plugin-permission-common';
import { PluginDatabaseManager } from '@backstage/backend-common';
import { PluginEndpointDiscovery } from '@backstage/backend-common';
import { processingResult } from '@backstage/plugin-catalog-node';
import { Readable } from 'stream';
import { ResourcePermission } from '@backstage/plugin-permission-common';
import { Router } from 'express';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { TokenManager } from '@backstage/backend-common';
import { UrlReader } from '@backstage/backend-common';
import { Validators } from '@backstage/catalog-model';

/**
 *
 * This is where I get really vague. Something like this perhaps? Or it could be
 * something like a json-schema that contains enough info for the frontend to
 * be able to present a form and explanations
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
export declare type AnalyzeLocationEntityField = AnalyzeLocationEntityField_2;

/**
 * If the folder pointed to already contained catalog info yaml files, they are
 * read and emitted like this so that the frontend can inform the user that it
 * located them and can make sure to register them as well if they weren't
 * already
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
export declare type AnalyzeLocationExistingEntity = AnalyzeLocationExistingEntity_2;

/**
 * This is some form of representation of what the analyzer could deduce.
 * We should probably have a chat about how this can best be conveyed to
 * the frontend. It'll probably contain a (possibly incomplete) entity, plus
 * enough info for the frontend to know what form data to show to the user
 * for overriding/completing the info.
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
export declare type AnalyzeLocationGenerateEntity = AnalyzeLocationGenerateEntity_2;

/**
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
export declare type AnalyzeLocationRequest = AnalyzeLocationRequest_2;

/**
 * @public
 * @deprecated use the same type from `@backstage/plugin-catalog-common` instead
 */
export declare type AnalyzeLocationResponse = AnalyzeLocationResponse_2;

/** @public */
export declare type AnalyzeOptions = {
    url: string;
    catalogFilename?: string;
};

/** @public */
export declare class AnnotateLocationEntityProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
    });
    getProcessorName(): string;
    preProcessEntity(entity: Entity, location: LocationSpec, _: CatalogProcessorEmit, originLocation: LocationSpec): Promise<Entity>;
}

/** @public */
export declare class AnnotateScmSlugEntityProcessor implements CatalogProcessor {
    private readonly opts;
    constructor(opts: {
        scmIntegrationRegistry: ScmIntegrationRegistry;
    });
    getProcessorName(): string;
    static fromConfig(config: Config): AnnotateScmSlugEntityProcessor;
    preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

/** @public */
export declare class BuiltinKindsEntityProcessor implements CatalogProcessor {
    private readonly validators;
    getProcessorName(): string;
    validateEntityKind(entity: Entity): Promise<boolean>;
    postProcessEntity(entity: Entity, _location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
}

/**
 * A builder that helps wire up all of the component parts of the catalog.
 *
 * The touch points where you can replace or extend behavior are as follows:
 *
 * - Entity policies can be added or replaced. These are automatically run
 *   after the processors' pre-processing steps. All policies are given the
 *   chance to inspect the entity, and all of them have to pass in order for
 *   the entity to be considered valid from an overall point of view.
 * - Location analyzers can be added. These are responsible for analyzing
 *   repositories when onboarding them into the catalog, by finding
 *   catalog-info.yaml files and other artifacts that can help automatically
 *   register or create catalog data on the user's behalf.
 * - Placeholder resolvers can be replaced or added. These run on the raw
 *   structured data between the parsing and pre-processing steps, to replace
 *   dollar-prefixed entries with their actual values (like $file).
 * - Field format validators can be replaced. These check the format of
 *   individual core fields such as metadata.name, to ensure that they adhere
 *   to certain rules.
 * - Processors can be added or replaced. These implement the functionality of
 *   reading, parsing, validating, and processing the entity data before it is
 *   persisted in the catalog.
 *
 * @public
 */
export declare class CatalogBuilder {
    private readonly env;
    private entityPolicies;
    private entityPoliciesReplace;
    private placeholderResolvers;
    private fieldFormatValidators;
    private entityProviders;
    private processors;
    private locationAnalyzers;
    private processorsReplace;
    private parser;
    private onProcessingError?;
    private processingInterval;
    private locationAnalyzer;
    private readonly permissionRules;
    private allowedLocationType;
    /**
     * Creates a catalog builder.
     */
    static create(env: CatalogEnvironment): CatalogBuilder;
    private constructor();
    /**
     * Adds policies that are used to validate entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link CatalogBuilder#setFieldFormatValidators} instead.
     *
     * @param policies - One or more policies
     */
    addEntityPolicy(...policies: Array<EntityPolicy | Array<EntityPolicy>>): CatalogBuilder;
    /**
     * Processing interval determines how often entities should be processed.
     * Seconds provided will be multiplied by 1.5
     * The default processing interval is 100-150 seconds.
     * setting this too low will potentially deplete request quotas to upstream services.
     */
    setProcessingIntervalSeconds(seconds: number): CatalogBuilder;
    /**
     * Overwrites the default processing interval function used to spread
     * entity updates in the catalog.
     */
    setProcessingInterval(processingInterval: ProcessingIntervalFunction): CatalogBuilder;
    /**
     * Overwrites the default location analyzer.
     */
    setLocationAnalyzer(locationAnalyzer: LocationAnalyzer): CatalogBuilder;
    /**
     * Sets what policies to use for validation of entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link CatalogBuilder#setFieldFormatValidators} instead.
     *
     * This function replaces the default set of policies; use with care.
     *
     * @param policies - One or more policies
     */
    replaceEntityPolicies(policies: EntityPolicy[]): CatalogBuilder;
    /**
     * Adds, or overwrites, a handler for placeholders (e.g. $file) in entity
     * definition files.
     *
     * @param key - The key that identifies the placeholder, e.g. "file"
     * @param resolver - The resolver that gets values for this placeholder
     */
    setPlaceholderResolver(key: string, resolver: PlaceholderResolver): CatalogBuilder;
    /**
     * Sets the validator function to use for one or more special fields of an
     * entity. This is useful if the default rules for formatting of fields are
     * not sufficient.
     *
     * This function has no effect if used together with
     * {@link CatalogBuilder#replaceEntityPolicies}.
     *
     * @param validators - The (subset of) validators to set
     */
    setFieldFormatValidators(validators: Partial<Validators>): CatalogBuilder;
    /**
     * Adds or replaces entity providers. These are responsible for bootstrapping
     * the list of entities out of original data sources. For example, there is
     * one entity source for the config locations, and one for the database
     * stored locations. If you ingest entities out of a third party system, you
     * may want to implement that in terms of an entity provider as well.
     *
     * @param providers - One or more entity providers
     */
    addEntityProvider(...providers: Array<EntityProvider | Array<EntityProvider>>): CatalogBuilder;
    /**
     * Adds entity processors. These are responsible for reading, parsing, and
     * processing entities before they are persisted in the catalog.
     *
     * @param processors - One or more processors
     */
    addProcessor(...processors: Array<CatalogProcessor | Array<CatalogProcessor>>): CatalogBuilder;
    /**
     * Sets what entity processors to use. These are responsible for reading,
     * parsing, and processing entities before they are persisted in the catalog.
     *
     * This function replaces the default set of processors, consider using with
     * {@link CatalogBuilder#getDefaultProcessors}; use with care.
     *
     * @param processors - One or more processors
     */
    replaceProcessors(processors: CatalogProcessor[]): CatalogBuilder;
    /**
     * Returns the default list of entity processors. These are responsible for reading,
     * parsing, and processing entities before they are persisted in the catalog. Changing
     * the order of processing can give more control to custom processors.
     *
     * Consider using with {@link CatalogBuilder#replaceProcessors}
     *
     */
    getDefaultProcessors(): CatalogProcessor[];
    /**
     * Adds Location Analyzers. These are responsible for analyzing
     * repositories when onboarding them into the catalog, by finding
     * catalog-info.yaml files and other artifacts that can help automatically
     * register or create catalog data on the user's behalf.
     *
     * @param locationAnalyzers - One or more location analyzers
     */
    addLocationAnalyzers(...analyzers: Array<ScmLocationAnalyzer | Array<ScmLocationAnalyzer>>): CatalogBuilder;
    /**
     * Sets up the catalog to use a custom parser for entity data.
     *
     * This is the function that gets called immediately after some raw entity
     * specification data has been read from a remote source, and needs to be
     * parsed and emitted as structured data.
     *
     * @param parser - The custom parser
     */
    setEntityDataParser(parser: CatalogProcessorParser): CatalogBuilder;
    /* Excluded from this release type: addPermissionRules */
    /**
     * Sets up the allowed location types from being registered via the location service.
     *
     * @param allowedLocationTypes - the allowed location types
     */
    setAllowedLocationTypes(allowedLocationTypes: string[]): CatalogBuilder;
    /**
     * Wires up and returns all of the component parts of the catalog
     */
    build(): Promise<{
        processingEngine: CatalogProcessingEngine;
        router: Router;
    }>;
    subscribe(options: {
        onProcessingError: (event: {
            unprocessedEntity: Entity;
            errors: Error[];
        }) => Promise<void> | void;
    }): void;
    private buildEntityPolicy;
    private buildProcessors;
    private checkDeprecatedReaderProcessors;
    private checkMissingExternalProcessors;
}

/* Excluded from this release type: catalogConditions */

/** @public */
export declare type CatalogEnvironment = {
    logger: Logger;
    database: PluginDatabaseManager;
    config: Config;
    reader: UrlReader;
    permissions: PermissionEvaluator | PermissionAuthorizer;
};

/* Excluded from this release type: CatalogPermissionRule */

/* Excluded from this release type: catalogPlugin */

/** @public */
export declare interface CatalogProcessingEngine {
    start(): Promise<void>;
    stop(): Promise<void>;
}

export { CatalogProcessor }

export { CatalogProcessorCache }

export { CatalogProcessorEmit }

export { CatalogProcessorEntityResult }

export { CatalogProcessorErrorResult }

export { CatalogProcessorLocationResult }

export { CatalogProcessorParser }

export { CatalogProcessorRefreshKeysResult }

export { CatalogProcessorRelationResult }

export { CatalogProcessorResult }

/** @public */
export declare class CodeOwnersProcessor implements CatalogProcessor {
    private readonly integrations;
    private readonly logger;
    private readonly reader;
    static fromConfig(config: Config, options: {
        logger: Logger;
        reader: UrlReader;
    }): CodeOwnersProcessor;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
        logger: Logger;
        reader: UrlReader;
    });
    getProcessorName(): string;
    preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

/* Excluded from this release type: createCatalogConditionalDecision */

/* Excluded from this release type: createCatalogPermissionRule */

/**
 * Creates a function that returns a random processing interval between minSeconds and maxSeconds.
 * @returns A {@link ProcessingIntervalFunction} that provides the next processing interval
 * @public
 */
export declare function createRandomProcessingInterval(options: {
    minSeconds: number;
    maxSeconds: number;
}): ProcessingIntervalFunction;

/**
 * @public
 * @deprecated Upgrade to a more recent `@backstage/plugin-search-backend-node` and
 * use `DefaultCatalogCollatorFactory` instead.
 */
export declare class DefaultCatalogCollator {
    protected discovery: PluginEndpointDiscovery;
    protected locationTemplate: string;
    protected filter?: GetEntitiesRequest['filter'];
    protected readonly catalogClient: CatalogApi;
    readonly type: string;
    readonly visibilityPermission: Permission;
    protected tokenManager: TokenManager;
    static fromConfig(_config: Config, options: {
        discovery: PluginEndpointDiscovery;
        tokenManager: TokenManager;
        filter?: GetEntitiesRequest['filter'];
    }): DefaultCatalogCollator;
    constructor(options: {
        discovery: PluginEndpointDiscovery;
        tokenManager: TokenManager;
        locationTemplate?: string;
        filter?: GetEntitiesRequest['filter'];
        catalogClient?: CatalogApi;
    });
    protected applyArgsToFormat(format: string, args: Record<string, string>): string;
    private getDocumentText;
    execute(): Promise<CatalogEntityDocument[]>;
}

/** @public */
export declare class DefaultCatalogCollatorFactory implements DocumentCollatorFactory {
    readonly type: string;
    readonly visibilityPermission: Permission;
    private locationTemplate;
    private filter?;
    private batchSize;
    private readonly catalogClient;
    private tokenManager;
    static fromConfig(_config: Config, options: DefaultCatalogCollatorFactoryOptions): DefaultCatalogCollatorFactory;
    private constructor();
    getCollator(): Promise<Readable>;
    private applyArgsToFormat;
    private execute;
}

/** @public */
export declare type DefaultCatalogCollatorFactoryOptions = {
    discovery: PluginEndpointDiscovery;
    tokenManager: TokenManager;
    locationTemplate?: string;
    filter?: GetEntitiesRequest['filter'];
    batchSize?: number;
    catalogClient?: CatalogApi;
};

export { DeferredEntity }

/**
 * Matches rows in the search table.
 * @public
 */
export declare type EntitiesSearchFilter = {
    /**
     * The key to match on.
     *
     * Matches are always case insensitive.
     */
    key: string;
    /**
     * Match on plain equality of values.
     *
     * Match on values that are equal to any of the given array items. Matches are
     * always case insensitive.
     */
    values?: string[];
};

/**
 * A filter expression for entities.
 *
 * Any (at least one) of the outer sets must match, within which all of the
 * individual filters must match.
 * @public
 */
export declare type EntityFilter = {
    allOf: EntityFilter[];
} | {
    anyOf: EntityFilter[];
} | {
    not: EntityFilter;
} | EntitiesSearchFilter;

export { EntityProvider }

export { EntityProviderConnection }

export { EntityProviderMutation }

export { EntityRelationSpec }

/** @public */
export declare class FileReaderProcessor implements CatalogProcessor {
    getProcessorName(): string;
    readLocation(location: LocationSpec, optional: boolean, emit: CatalogProcessorEmit, parser: CatalogProcessorParser): Promise<boolean>;
}

/** @public */
export declare type LocationAnalyzer = {
    /**
     * Generates an entity configuration for given git repository. It's used for
     * importing new component to the backstage app.
     *
     * @param location - Git repository to analyze and generate config for.
     */
    analyzeLocation(location: AnalyzeLocationRequest): Promise<AnalyzeLocationResponse>;
};

/** @public */
export declare class LocationEntityProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: LocationEntityProcessorOptions);
    getProcessorName(): string;
    postProcessEntity(entity: Entity, location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
}

/** @public */
export declare type LocationEntityProcessorOptions = {
    integrations: ScmIntegrationRegistry;
};

export { LocationSpec }

/** @public */
export declare function locationSpecToLocationEntity(opts: {
    location: LocationSpec;
    parentEntity?: Entity;
}): LocationEntityV1alpha1;

/** @public */
export declare function parseEntityYaml(data: Buffer, location: LocationSpec): Iterable<CatalogProcessorResult>;

/* Excluded from this release type: permissionRules */

/**
 * Traverses raw entity JSON looking for occurrences of $-prefixed placeholders
 * that it then fills in with actual data.
 * @public
 */
export declare class PlaceholderProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: PlaceholderProcessorOptions);
    getProcessorName(): string;
    preProcessEntity(entity: Entity, location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
}

/** @public */
export declare type PlaceholderProcessorOptions = {
    resolvers: Record<string, PlaceholderResolver>;
    reader: UrlReader;
    integrations: ScmIntegrationRegistry;
};

/** @public */
export declare type PlaceholderResolver = (params: PlaceholderResolverParams) => Promise<JsonValue>;

/** @public */
export declare type PlaceholderResolverParams = {
    key: string;
    value: JsonValue;
    baseUrl: string;
    read: PlaceholderResolverRead;
    resolveUrl: PlaceholderResolverResolveUrl;
    emit: CatalogProcessorEmit;
};

/** @public */
export declare type PlaceholderResolverRead = (url: string) => Promise<Buffer>;

/** @public */
export declare type PlaceholderResolverResolveUrl = (url: string, base: string) => string;

/**
 * Function that returns the catalog processing interval in seconds.
 * @public
 */
export declare type ProcessingIntervalFunction = () => number;

export { processingResult }

/** @public */
export declare type ScmLocationAnalyzer = {
    /** The method that decides if this analyzer can work with the provided url */
    supports(url: string): boolean;
    /** This function can return an array of already existing entities */
    analyze(options: AnalyzeOptions): Promise<{
        /** Existing entities in the analyzed location */
        existing: AnalyzeLocationExistingEntity[];
    }>;
};

/** @public */
export declare class UrlReaderProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: {
        reader: UrlReader;
        logger: Logger;
    });
    getProcessorName(): string;
    readLocation(location: LocationSpec, optional: boolean, emit: CatalogProcessorEmit, parser: CatalogProcessorParser, cache: CatalogProcessorCache): Promise<boolean>;
    private doRead;
}

export { }
